---
title: What happens when you send 1 DAI
authorURL: ""
originalURL: https://www.notonlyowner.com/learn/what-happens-when-you-send-one-dai
translator: "fengjy73"
reviewer: ""
---

# å½“ä½ å‘é€1DAIçš„æ—¶å€™ä¼šå‘ç”Ÿä»€ä¹ˆ

<!-- more -->

---

![article cover](https://notonlyowner.com/images/what-happens-dai-cover-intro.png)

ä½ æ‹¥æœ‰1ä¸ª [DAI][2].

ä½¿ç”¨é’±åŒ…ç•Œé¢ (ä¾‹å¦‚ [Metamask][3]), ä½ ç‚¹å‡»è¶³å¤Ÿå¤šçš„æŒ‰é’®å¹¶è¾“å…¥è¶³å¤Ÿå¤šçš„æ–‡æœ¬æ¥ç¡®è®¤æ‚¨è¦å‘`0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045` (å³vitalik.eth)è¿™ä¸ªåœ°å€å‘é€ 1 DAIã€‚

ç„¶åç‚¹å‡»å‘é€

ä¸€æ®µæ—¶é—´åï¼Œé’±åŒ…æ˜¾ç¤ºäº¤æ˜“å·²ç¡®è®¤ã€‚çªç„¶é—´ï¼ŒVitalik å¤šäº† 1 ä¸ª DAIã€‚åˆ°åº•å‘ç”Ÿäº†ä»€ä¹ˆï¼Ÿ

è®©æˆ‘ä»¬å€’å¸¦ã€‚ç„¶åä»¥æ…¢åŠ¨ä½œé‡æ’­è¿™ä¸ªè¿‡ç¨‹ã€‚

å‡†å¤‡å¥½äº†å—?

---

## ç›®å½•

1.  [æ„å»ºäº¤æ˜“][4]
    -   [äº¤æ˜“çš„æ•°æ®å­—æ®µ][5]
    -   [Gasçš„é­”æ³•][6]
    -   [è®¿é—®æ§åˆ¶åˆ—è¡¨å’Œäº¤æ˜“ç±»å‹][7]
    -   [å¯¹äº¤æ˜“ç­¾å][8]
    -   [åºåˆ—åŒ–][9]
    -   [æäº¤äº¤æ˜“][10]
2.  [æ¥æ”¶äº¤æ˜“][11]
    -   [æ£€æŸ¥å†…å­˜æ± ][12]
3.  [ä¼ æ’­][13]
4.  [å‡†å¤‡å·¥ä½œå’Œäº¤æ˜“æ‰“åŒ…][14]
5.  [æ‰§è¡Œ][15]
    -   [å‡†å¤‡å·¥ä½œ(ç¬¬1éƒ¨åˆ†)][16]
    -   [å‡†å¤‡å·¥ä½œ(ç¬¬2éƒ¨åˆ†)][17]
    -   [è°ƒç”¨][18]
    -   [è§£é‡Šå™¨(ç¬¬1éƒ¨åˆ†)][19]
    -   [Solidityæ‰§è¡Œ][20]
    -   [EVMæ‰§è¡Œ][21]
        -   [é‡Šæ”¾å†…å­˜æŒ‡é’ˆå¹¶è°ƒç”¨å€¼][22]
        -   [éªŒè¯calldata (ç¬¬1éƒ¨åˆ†)][23]
        -   [å‡½æ•°è°ƒåº¦å™¨][24]
        -   [éªŒè¯calldata (ç¬¬2éƒ¨åˆ†)][25]
        -   [è¯»å–å‚æ•°][26]
        -   [transferå‡½æ•°][27]
        -   [transferFromå‡½æ•°][28]
        -   [æ—¥å¿—è®°å½•][29]
        -   [è¿”å›][30]
    -   [è§£é‡Šå™¨(ç¬¬2éƒ¨åˆ†)][31]
    -   [Gasé€€è¿˜å’Œæ”¶å–][32]
    -   [æ„å»ºäº¤æ˜“æ”¶æ®][33]
6.  [æ‰“åŒ…åŒºå—][34]
7.  [å¹¿æ’­åŒºå—][35]
8.  [éªŒè¯åŒºå—][36]
9.  [æ£€ç´¢äº¤æ˜“][37]
10.  [åè®°][38]

---

## æ„å»ºäº¤æ˜“

[é’±åŒ…][39] æ˜¯ä¸€ç§å¯ä»¥æ–¹ä¾¿åœ°å‘ä»¥å¤ªåŠç½‘ç»œå‘é€ _äº¤æ˜“_ çš„è½¯ä»¶.

ä¸€ç¬”äº¤æ˜“æ˜¯ä½ ä½œä¸ºç”¨æˆ·å‘Šè¯‰ä»¥å¤ªåŠç½‘ç»œä½ æƒ³æ‰§è¡Œä¸€ä¸ªæ“ä½œçš„æ–¹å¼ã€‚åœ¨è¿™ä¸ªæ¡ˆä¾‹ä¸­ï¼Œä½ å…ˆæ‰§è¡Œçš„æ“ä½œæ˜¯å‘Vitalikå‘é€1ä¸ªDAIã€‚é’±åŒ…ï¼ˆä¾‹å¦‚Metamaskï¼‰ä»¥ç›¸å¯¹æ–°æ‰‹å‹å¥½çš„æ–¹å¼å¸®åŠ©æ„å»ºè¿™æ ·çš„äº¤æ˜“ã€‚

è®©æˆ‘ä»¬é¦–å…ˆé€Ÿè§ˆä¸€ä¸‹é’±åŒ…å°†æ„å»ºçš„äº¤æ˜“ã€‚å®ƒå¯ä»¥è¡¨ç¤ºä¸ºä¸€ä¸ªå…·æœ‰å­—æ®µåŠå…¶ç›¸åº”æ•°å€¼çš„å¯¹è±¡ã€‚

åœ¨æˆ‘ä»¬çš„æ¡ˆä¾‹ä¸­ï¼Œæœ€å¼€å§‹çœ‹èµ·æ¥æ˜¯è¿™æ ·çš„:

`{     "to": "0x6b175474e89094c44da98b954eedeac495271d0f",     // [...] }`

å…¶ä¸­ å­—æ®µ _to_ è¡¨ç¤ºç›®æ ‡åœ°å€. åœ¨æœ¬æ¡ˆä¾‹ä¸­, `0x6b175474e89094c44da98b954eedeac495271d0f` æ˜¯DAIæ™ºèƒ½åˆçº¦çš„åœ°å€.

ç­‰ç­‰, å‘ç”Ÿäº†ä»€ä¹ˆ?

æˆ‘ä»¬ä¸æ˜¯åº”è¯¥å‘Vitalikå‘é€1ä¸ªDAIå—ï¼Ÿ `to` éš¾é“ä¸æ˜¯åº”è¯¥æ˜¯ Vitalik çš„åœ°å€å—?


å‘é€ DAI æ—¶ï¼ŒåŸºæœ¬ä¸Šå¿…é¡»æ„å»ºä¸€ä¸ªäº¤æ˜“ï¼Œç”¨æ¥æ‰§è¡Œå­˜å‚¨åœ¨åŒºå—é“¾ï¼ˆä¹Ÿå°±æ˜¯ä»¥å¤ªåŠæ•°æ®åº“çš„ä¸€ä¸ªèŠ±å“¨åç§°ï¼‰ä¸­çš„ä¸€æ®µä»£ç ï¼Œä»è€Œ _æ›´æ–°_ DAI ä½™é¢è®°å½•ã€‚æ‰§è¡Œæ­¤ç±»æ›´æ–°æ‰€éœ€çš„é€»è¾‘å’Œç›¸å…³å­˜å‚¨éƒ½ä¿å­˜åœ¨ä»¥å¤ªåŠæ•°æ®åº“ä¸­çš„ä¸€ä¸ªä¸å¯ç¯¡æ”¹çš„ã€å…¬å…±çš„è®¡ç®—æœºç¨‹åºä¸­ã€‚å³ DAI æ™ºèƒ½åˆçº¦ã€‚

å› æ­¤ï¼Œä½ æƒ³æ„å»ºä¸€ç¬”äº¤æ˜“æ¥å‘Šè¯‰åˆçº¦â€œå˜¿ï¼Œæœ‹å‹ï¼Œæ›´æ–°ä½ çš„å†…éƒ¨ä½™é¢å§ï¼Œä»æˆ‘çš„ä½™é¢ä¸­å–å‡º1ä¸ªDAIï¼Œå¹¶å°†1ä¸ªDAIæ·»åŠ åˆ°Vitalikçš„ä½™é¢ä¸­â€ã€‚åœ¨ä»¥å¤ªåŠè¡Œè¯ä¸­ï¼Œâ€œå˜¿ï¼Œæœ‹å‹â€è¿™ä¸ªçŸ­è¯­è¢«ç¿»è¯‘ä¸ºåœ¨äº¤æ˜“çš„ `to` å­—æ®µä¸­è®¾ç½®DAIçš„åœ°å€ã€‚

ç„¶è€Œï¼Œ å…‰æœ‰`to` å­—æ®µè¿˜ä¸è¶³å¤Ÿã€‚æ ¹æ®ä½ åœ¨ä½ æœ€å–œæ¬¢çš„é’±åŒ…ç•Œé¢æä¾›çš„ä¿¡æ¯ï¼Œé’±åŒ…ä¼šå¡«å†™å…¶ä»–å‡ ä¸ªå­—æ®µï¼Œä»è€Œæ„å»ºæ ¼å¼å®Œæ•´çš„äº¤æ˜“ã€‚

`{     "to": "0x6b175474e89094c44da98b954eedeac495271d0f",     "amount": 0,     "chainId": 31337,     "nonce": 0,     // [...] }`

å®ƒç”¨ `0` å¡«å……äº† `amount` å­—æ®µã€‚æ‰€ä»¥ä½ è¦å‘ Vitalik å‘é€ `1` DAIï¼Œæ—¢ä¸ä½¿ç”¨ Vitalik çš„åœ°å€ï¼Œä¹Ÿä¸åœ¨ `amount` å­—æ®µä¸­æ”¾ç½® `1` ã€‚è¿™å°±æ˜¯ç”Ÿæ´»çš„è‰°è¾›ï¼ˆæˆ‘ä»¬åªæ˜¯åœ¨çƒ­èº«ï¼‰ã€‚ `amount` å­—æ®µä¹Ÿéœ€è¦åœ¨äº¤æ˜“ä¸­åŒ…å«æ˜¯å› ä¸ºè¦ç”¨äºæŒ‡å®šä½ åœ¨äº¤æ˜“ä¸­å‘é€äº†å¤šå°‘ä»¥å¤ªå¸ï¼ˆä»¥å¤ªåŠçš„åŸç”Ÿè´§å¸ï¼‰ã€‚ç”±äºä½ ç°åœ¨ä¸æƒ³å‘é€ä»¥å¤ªå¸ï¼Œé‚£ä¹ˆé’±åŒ…ä¼šæ­£ç¡®åœ°å°†è¯¥å­—æ®µè®¾ç½®ä¸º `0`ã€‚

è‡³äº `chainId` , å®ƒæ˜¯ä¸€ä¸ªç”¨äºæŒ‡å®šäº¤æ˜“åœ¨å“ªæ¡é“¾ä¸Šè¢«æ‰§è¡Œçš„å­—æ®µ. å¯¹äºä»¥å¤ªåŠçš„ä¸»ç½‘, `chainId` çš„å€¼æ˜¯1. ç„¶è€Œ,  **ç”±äºæˆ‘ä»¬è¦åœ¨ä¸»ç½‘çš„æœ¬åœ°å‰¯æœ¬ä¸Šè¿›è¡Œè¿™ä¸ªå®éªŒ**, æ‰€ä»¥æˆ‘å°†chain IDæŒ‡å®šä¸ºäº†: 31337. [å…¶ä»–çš„é“¾å…·æœ‰å…¶ä»–çš„IDå·][40].

å…³äº `nonce` å­—æ®µå‘¢ï¼Ÿè¿™æ˜¯ä¸€ä¸ªæ•°å­—ï¼Œæ¯æ¬¡å‘ç½‘ç»œå‘é€äº¤æ˜“æ—¶éƒ½åº”è¯¥å¢åŠ å®ƒã€‚å®ƒæ˜¯ä¸€ç§ç”¨äºé¿å…é‡æ”¾é—®é¢˜çš„é˜²å¾¡æœºåˆ¶ã€‚é’±åŒ…é€šå¸¸ä¼šä¸ºæ‚¨è®¾ç½®å®ƒã€‚ä¸ºæ­¤ï¼Œå®ƒä»¬æŸ¥è¯¢ç½‘ç»œï¼ŒæŸ¥è¯¢æ‚¨çš„è´¦æˆ·æœ€æ–°ä½¿ç”¨çš„`nonce`å€¼ï¼Œç„¶åç›¸åº”åœ°è®¾ç½®å½“å‰äº¤æ˜“çš„`nonce`å€¼ã€‚åœ¨ä¸Šé¢çš„ç¤ºä¾‹ä¸­ï¼Œå®ƒè®¾ç½®ä¸º0ï¼Œä½†å®é™…ä¸Šè¿™å°†å–å†³äºæ‚¨çš„è´¦æˆ·å·²ç»æ‰§è¡Œçš„äº¤æ˜“æ•°é‡ã€‚

æˆ‘åˆšåˆšè¯´é’±åŒ…â€œæŸ¥è¯¢ç½‘ç»œâ€ã€‚æˆ‘çš„æ„æ€æ˜¯é’±åŒ…å¯¹ä»¥å¤ªåŠèŠ‚ç‚¹æ‰§è¡Œåªè¯»è°ƒç”¨ï¼Œç„¶åèŠ‚ç‚¹ä¼šç”¨è¯·æ±‚çš„æ•°æ®è¿›è¡Œå“åº”ã€‚æœ‰å¤šç§æ–¹å¼å¯ä»¥ä»ä»¥å¤ªåŠèŠ‚ç‚¹è¯»å–æ•°æ®ï¼Œè¿™å–å†³äºèŠ‚ç‚¹çš„ä½ç½®ä»¥åŠå®ƒæ‰€å…¬å¼€çš„APIç±»å‹ã€‚

è®©æˆ‘ä»¬æƒ³è±¡ä¸€ä¸‹ï¼Œé’±åŒ…å·²ç»ç›´è¿åˆ°ä»¥å¤ªåŠèŠ‚ç‚¹çš„ç½‘ç»œã€‚ä¸è¿‡æ›´å¸¸è§çš„æƒ…å†µæ˜¯ï¼Œé’±åŒ…æ˜¯ä¸ç¬¬ä¸‰æ–¹æä¾›å•†ï¼ˆå¦‚Infuraã€Alchemyã€QuickNodeç­‰ï¼‰è¿›è¡Œäº¤äº’ã€‚ä¸èŠ‚ç‚¹äº¤äº’çš„è¯·æ±‚éµå¾ªç‰¹æ®Šçš„åè®®ï¼Œä»¥æ‰§è¡Œè¿œç¨‹è°ƒç”¨ã€‚è¿™ä¸ªåè®®è¢«ç§°ä¸º [JSON-RPC][41]ã€‚

é’±åŒ…å‘å‡ºçš„å°è¯•è·å–è´¦æˆ·`nonce`çš„è¯·æ±‚å°†ç±»ä¼¼äºä»¥ä¸‹å†…å®¹ï¼š

`POST / HTTP/1.1 connection: keep-alive Content-Type: application/json content-length: 124  {     "jsonrpc":"2.0",     "method":"eth_getTransactionCount",     "params":["0x6fC27A75d76d8563840691DDE7a947d7f3F179ba","latest"],     "id":6 } --- HTTP/1.1 200 OK Content-Type: application/json Content-Length: 42  {"jsonrpc":"2.0","id":6,"result":"0x0"}`

å…¶ä¸­ï¼Œå‘é€æ–¹çš„è´¦æˆ·åº”è¯¥æ˜¯ `0x6fC27A75d76d8563840691DDE7a947d7f3F179ba`ã€‚ ä»å“åº”çš„æ•°æ®ä¸­å¯ä»¥çœ‹åˆ°å®ƒçš„nonceå€¼æ˜¯0

é’±åŒ…é€šè¿‡ç½‘ç»œè¯·æ±‚è·å–æ•°æ®ï¼ˆåœ¨æœ¬ä¾‹ä¸­ï¼Œé€šè¿‡HTTPï¼‰ï¼Œä»¥è®¿é—®èŠ‚ç‚¹å…¬å¼€çš„JSON-RPCç«¯ç‚¹ã€‚ä¸Šé¢æˆ‘åªå†™äº†ä¸€ä¸ªè¯·æ±‚ï¼Œä½†å®é™…ä¸Šï¼Œé’±åŒ…å¯ä»¥æŸ¥è¯¢å®ƒä»¬éœ€è¦æ„å»ºäº¤æ˜“çš„ä»»ä½•æ•°æ®ã€‚å¦‚æœåœ¨ç°å®æ¡ˆä¾‹ä¸­æ³¨æ„åˆ°æ›´å¤šçš„ç½‘ç»œè¯·æ±‚æ¥æŸ¥æ‰¾å…¶ä»–å†…å®¹ï¼Œä¸è¦æ„Ÿåˆ°æƒŠè®¶ã€‚ä¾‹å¦‚ï¼Œä»¥ä¸‹æ˜¯å‡ åˆ†é’Ÿå†…Metamaskæµé‡è®¿é—®æœ¬åœ°æµ‹è¯•èŠ‚ç‚¹çš„ç‰‡æ®µï¼š

![åœ¨æœ¬åœ°ç½‘ç»œä¸­Metamaskæµé‡çš„Wiresharkæˆªå›¾å¿«ç…§](https://notonlyowner.com/images/metamask-traffic.png)

### äº¤æ˜“çš„æ•°æ®å­—æ®µ

DAIæ˜¯ä¸€ä¸ªæ™ºèƒ½åˆçº¦. å®ƒçš„æ ¸å¿ƒé€»è¾‘åœ¨ä»¥å¤ªåŠä¸»ç½‘`0x6b175474e89094c44da98b954eedeac495271d0f`è¿™ä¸ªåœ°å€ä¸Šå®ç°.

æ›´å…·ä½“åœ°è¯´ï¼ŒDAIæ˜¯ç¬¦åˆERC20æ ‡å‡†çš„åŒè´¨åŒ–ä»£å¸â€”â€”ä¸€ç§éå¸¸ç‰¹æ®Šçš„åˆçº¦ç±»å‹ã€‚è¿™æ„å‘³ç€è‡³å°‘DAIåº”è¯¥å®ç°[ERC20 æ ‡å‡†][42]ä¸­è¯¦ç»†æè¿°çš„æ¥å£ã€‚åœ¨ï¼ˆæœ‰äº›ç‰µå¼ºçš„ï¼‰web2è¡Œè¯ä¸­ï¼ŒDAIæ˜¯åœ¨ä»¥å¤ªåŠä¸Šè¿è¡Œçš„ä¸å¯ç¯¡æ”¹çš„å¼€æºç½‘ç»œæœåŠ¡ã€‚é‰´äºå®ƒéµå¾ªERC20è§„èŒƒï¼Œå¯ä»¥é¢„å…ˆçŸ¥é“ï¼ˆè€Œä¸ä¸€å®šè¦æŸ¥çœ‹æºä»£ç ï¼‰ä¸ä¹‹äº¤äº’çš„å…·ä½“å…¬å¼€çš„ç«¯ç‚¹ã€‚

çŸ­å°çš„è¯´æ˜ï¼šå¹¶éæ‰€æœ‰çš„ERC20ä»£å¸éƒ½æ˜¯ç›¸åŒçš„ã€‚å®ç°ç‰¹å®šæ¥å£ï¼ˆç”¨äºä¿ƒè¿›äº¤äº’å’Œé›†æˆï¼‰å¹¶ä¸ä¸€å®šä¿è¯å…·ä½“çš„è¡Œä¸ºã€‚å°½ç®¡å¦‚æ­¤ï¼Œå¯¹äºè¿™ä¸ªç»ƒä¹ ï¼Œæˆ‘ä»¬å¯ä»¥å®‰å…¨åœ°å‡è®¾DAIåœ¨è¡Œä¸ºä¸Šæ˜¯ä¸€ä¸ªç›¸å½“æ ‡å‡†çš„ERC20ä»£å¸ã€‚

DAIæ™ºèƒ½åˆçº¦ä¸­æœ‰è®¸å¤šåŠŸèƒ½ï¼ˆæºä»£ç å¯åœ¨[æ­¤å¤„][43]æ‰¾åˆ°ï¼‰ï¼Œå…¶ä¸­è®¸å¤šç›´æ¥å–è‡ªERC20è§„èŒƒã€‚ç‰¹åˆ«å¼•äººå…³æ³¨çš„æ˜¯[åªèƒ½è¢«åˆçº¦å¤–éƒ¨è°ƒç”¨çš„ `transfer` å‡½æ•°][44ã€‚

`contract Dai is LibNote {     ...     function transfer(address dst, uint wad) external returns (bool) {         ...     } }`

è¯¥å‡½æ•°å…è®¸æŒæœ‰ DAI ä»£å¸çš„ä»»ä½•äººå°†å…¶ä¸­ä¸€äº›ä»£å¸è½¬ç§»åˆ°å¦ä¸€ä¸ªä»¥å¤ªåŠè´¦æˆ·ã€‚å…¶å£°æ˜æ˜¯ `transfer(address,uint256)` ã€‚ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯æ¥æ”¶è´¦æˆ·çš„åœ°å€ï¼Œç¬¬äºŒä¸ªå‚æ•°æ˜¯è¡¨ç¤ºè¦è½¬ç§»çš„ä»£å¸æ•°é‡çš„æ— ç¬¦å·æ•´æ•°ã€‚

æš‚æ—¶ä¸è¦ä¸“æ³¨äºå‡½æ•°è¡Œä¸ºçš„å…·ä½“ç»†èŠ‚ã€‚ç›¸ä¿¡æˆ‘ï¼Œå½“å‡½æ•°æŒ‰ç…§é¢„æœŸè¿è¡Œæ—¶ï¼Œå®ƒä¼šå‡å°‘å‘é€è€…çš„ä½™é¢ï¼Œå¹¶ç›¸åº”åœ°å¢åŠ æ¥æ”¶è€…çš„ä½™é¢ã€‚

è¿™å¾ˆé‡è¦ï¼Œå› ä¸ºåœ¨æ„å»ºä¸æ™ºèƒ½åˆçº¦äº¤äº’çš„äº¤æ˜“æ—¶ï¼Œåº”è¯¥çŸ¥é“è¦æ‰§è¡Œåˆçº¦çš„å“ªä¸ªå‡½æ•°ï¼Œä»¥åŠè¦ä¼ é€’å“ªäº›å‚æ•°ã€‚å°±åƒåœ¨web2ä¸­ï¼Œå¦‚æœä½ æƒ³å‘web APIå‘é€POSTè¯·æ±‚ä¸€æ ·ã€‚æ‚¨å¾ˆå¯èƒ½éœ€è¦åœ¨è¯·æ±‚ä¸­æŒ‡å®šå¸¦æœ‰å‚æ•°çš„å‡†ç¡®çš„URLã€‚è¿™æ˜¯ä¸€æ ·çš„ã€‚æˆ‘ä»¬æƒ³è¦è½¬ç§»1ä¸ªDAIï¼Œæ‰€ä»¥æˆ‘ä»¬å¿…é¡»çŸ¥é“å¦‚ä½•åœ¨äº¤æ˜“ä¸­æŒ‡å®šè¦å»æ‰§è¡ŒDAIæ™ºèƒ½åˆçº¦ä¸Šçš„ `transfer` å‡½æ•°ã€‚

å¹¸è¿çš„æ˜¯ï¼Œè¿™æ˜¯éå¸¸ç›´æ¥å’Œç›´è§‚çš„ã€‚

å¼€ç©ç¬‘çš„ã€‚ä¸æ˜¯çš„ã€‚è¿™æ˜¯ä½ å¿…é¡»åŒ…æ‹¬åœ¨å‘é€1ä¸ªDAIç»™Vitalikè¿™ä¸ªäº¤æ˜“ä¸­å†…å®¹ï¼ˆè®°ä½ï¼Œåœ°å€æ˜¯ `0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045` ï¼‰ã€‚

`{     // [...]     "data": "0xa9059cbb000000000000000000000000d8da6bf26964af9d7eed9e03e53415d37aa960450000000000000000000000000000000000000000000000000de0b6b3a7640000" }`

è®©æˆ‘è§£é‡Šä¸€ä¸‹ã€‚

ä¸ºäº†ç®€åŒ–é›†æˆè¿‡ç¨‹å¹¶åˆ¶å®šä¸€ç§æ ‡å‡†åŒ–çš„æ–¹å¼ä¸æ™ºèƒ½åˆçº¦è¿›è¡Œäº¤äº’ï¼Œä»¥å¤ªåŠç”Ÿæ€ç³»ç»Ÿå·²ç»ï¼ˆä¸€å®šç¨‹åº¦ä¸Šï¼‰å¼€å§‹é‡‡ç”¨æ‰€è°“çš„â€œåˆçº¦ABIè§„èŒƒâ€ï¼ˆABIä»£è¡¨åº”ç”¨äºŒè¿›åˆ¶æ¥å£ï¼‰ã€‚åœ¨å¸¸è§çš„ä½¿ç”¨æƒ…å†µä¸‹ï¼Œæˆ‘å¼ºè°ƒï¼Œæ˜¯åœ¨å¸¸è§çš„ä½¿ç”¨æƒ…å†µä¸‹ï¼Œä¸ºäº†æ‰§è¡Œæ™ºèƒ½åˆçº¦å‡½æ•°ï¼Œæ‚¨å¿…é¡»é¦–å…ˆæŒ‰ç…§[åˆçº¦ABIè§„èŒƒ][45]å¯¹å‡½æ•°è°ƒç”¨è¿›è¡Œç¼–ç ã€‚æ›´é«˜é˜¶çš„ä½¿ç”¨æƒ…å†µå¯èƒ½ä¸éµå¾ªè¿™ä¸ªè§„èŒƒï¼Œä½†æˆ‘ä»¬ _ç»å¯¹_ ä¸ä¼šæ·±å…¥æ¢è®¨è¿™ä¸ªé—®é¢˜ã€‚å¯ä»¥è¯´ï¼Œé€šå¸¸ä½¿ç”¨[Solidity][46]ç¼–ç¨‹çš„æ™ºèƒ½åˆçº¦ï¼Œæ¯”å¦‚DAIï¼Œé€šå¸¸éµå¾ªåˆçº¦ABIè§„èŒƒã€‚


ä½ åœ¨ä¸Šé¢çœ‹åˆ°çš„æ˜¯å¯¹å°†1DAIè½¬è´¦åˆ°åœ°å€ `0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045` å¹¶ä½¿ç”¨DAIçš„ `transfer(address,uint256)` å‡½æ•°çš„è°ƒç”¨è¿›è¡ŒABIç¼–ç åå¾—åˆ°çš„å­—èŠ‚ ã€‚

æœ‰è®¸å¤šå·¥å…·å¯ä»¥å¯¹ABIè¿›è¡Œç¼–ç ï¼Œå¤§å¤šæ•°é’±åŒ…éƒ½åœ¨ä¸€å®šç¨‹åº¦ä¸Šå®ç°äº†ABIç¼–ç ä»¥ä¸åˆçº¦è¿›è¡Œäº¤äº’ã€‚ä¸ºäº†ä¸¾ä¾‹è¯´æ˜ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä¸€ä¸ªåä¸º[cast][47]çš„å‘½ä»¤è¡Œå·¥å…·æ¥éªŒè¯ä¸Šè¿°å­—èŠ‚åºåˆ—æ˜¯å¦æ­£ç¡®ï¼Œè¯¥ç¨‹åºèƒ½å¤Ÿä½¿ç”¨æŒ‡å®šå‚æ•°å¯¹è°ƒç”¨è¿›è¡ŒABIç¼–ç ï¼š

`$ cast calldata "transfer(address,uint256)" 0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045 1000000000000000000  0xa9059cbb000000000000000000000000d8da6bf26964af9d7eed9e03e53415d37aa960450000000000000000000000000000000000000000000000000de0b6b3a7640000`

æœ‰ä»€ä¹ˆå›°æ‰°ä½ çš„å—ï¼Ÿæ€ä¹ˆäº†ï¼Ÿ

æŠ±æ­‰ï¼Œæ˜¯çš„ã€‚é‚£ä¸ª1000000000000000000ã€‚è€å®è¯´ï¼Œæˆ‘ _çœŸçš„_ å¾ˆæƒ³ä¸ºä½ æä¾›æ›´æœ‰åŠ›çš„è®ºæ®ã€‚è§£é‡Šæ˜¯ï¼šè®¸å¤šERC20ä»£å¸ä½¿ç”¨18ä½å°æ•°è¿›è¡Œè¡¨ç¤ºï¼Œæ¯”å¦‚DAIã€‚ç„¶è€Œï¼Œæˆ‘ä»¬åªèƒ½ä½¿ç”¨æ— ç¬¦å·æ•´æ•°ã€‚å› æ­¤ï¼Œ1ä¸ªDAIå®é™…ä¸Šå­˜å‚¨ä¸º1 \* 10^18 - ä¹Ÿå°±æ˜¯1000000000000000000ã€‚å°±è¿™æ ·å§ã€‚

æˆ‘ä»¬æœ‰ä¸€ä¸ªç¾ä¸½çš„ABIç¼–ç çš„å­—èŠ‚åºåˆ—ï¼Œå®ƒéœ€è¦è¢«åŒ…å«åœ¨äº¤æ˜“çš„ `data` å­—æ®µä¸­ã€‚åˆ°ç›®å‰ä¸ºæ­¢æˆ‘ä»¬æ„å»ºçš„äº¤æ˜“çœ‹èµ·æ¥æ˜¯ï¼š

`{     "to": "0x6b175474e89094c44da98b954eedeac495271d0f",     "amount": 0,     "chainId": 31337,     "nonce": 0,     "data": "0xa9059cbb000000000000000000000000d8da6bf26964af9d7eed9e03e53415d37aa960450000000000000000000000000000000000000000000000000de0b6b3a7640000" }`

ä¸€æ—¦æˆ‘ä»¬å¼€å§‹å®é™…æ‰§è¡Œäº¤æ˜“ï¼Œæˆ‘ä»¬å°†é‡æ–°å®¡è§†è¿™ä¸ª data å­—æ®µçš„å†…å®¹ã€‚

### Gasçš„é­”æ³•

ä¸‹ä¸€ä¸ªæ­¥éª¤æ˜¯ï¼Œè¦ç¡®å®šä¸ºäº¤æ˜“æ”¯ä»˜å¤šå°‘è´¹ç”¨ã€‚è¯·è®°ä½ï¼Œæ‰€æœ‰äº¤æ˜“éƒ½å¿…é¡»å‘ç½‘ç»œä¸­çš„èŠ‚ç‚¹æ”¯ä»˜è´¹ç”¨ï¼Œå› ä¸ºè¿™äº›èŠ‚ç‚¹éœ€è¦æ—¶é—´å’Œèµ„æºæ¥æ‰§è¡Œå’ŒéªŒè¯å®ƒä»¬ã€‚

æ‰§è¡Œäº¤æ˜“çš„æˆæœ¬æ˜¯ä»¥ä»¥å¤ªå¸æ”¯ä»˜çš„ã€‚æœ€ç»ˆçš„ä»¥å¤ªå¸æ•°é‡å°†å–å†³äºä½ çš„äº¤æ˜“æ¶ˆè€—äº†å¤šå°‘[gas][48]ï¼ˆå³è®¡ç®—æˆæœ¬æœ‰å¤šé«˜ï¼‰ã€ä½ æ„¿æ„ä¸ºæ¯ä¸ªgaså•ä½èŠ±é”€æ”¯ä»˜å¤šå°‘ä»¥åŠç½‘ç»œæ„¿æ„æ¥å—çš„æœ€ä½é‡‘é¢æ˜¯å¤šå°‘ã€‚

ä»ç”¨æˆ·çš„è§’åº¦æ¥çœ‹ï¼Œåº•çº¿ _é€šå¸¸_ æ˜¯æ”¯ä»˜çš„é‡‘é¢è¶Šå¤šï¼Œäº¤æ˜“è¢«æ‰“åŒ…åœ¨åŒºå—é‡Œçš„é€Ÿåº¦å°±è¶Šå¿«ã€‚å› æ­¤ï¼Œå¦‚æœä½ æƒ³åœ¨ä¸‹ä¸€ä¸ªåŒºå—ä¸­æ”¯ä»˜ Vitalik 1 ä¸ª DAIï¼Œä½ å¯èƒ½éœ€è¦è®¾ç½®æ¯”æ„¿æ„ç­‰å¾…å‡ åˆ†é’Ÿï¼ˆæˆ–æ›´é•¿æ—¶é—´ï¼Œæœ‰æ—¶ _ç”šè‡³_ æ›´é•¿ï¼‰ç›´åˆ° gas ä»·æ ¼æ›´ä¾¿å®œæ—¶æ›´é«˜çš„è´¹ç”¨ã€‚

ä¸åŒçš„é’±åŒ…å¯èƒ½ä¼šé‡‡å–ä¸åŒçš„æ–¹å¼æ¥å†³å®šæ”¯ä»˜å¤šå°‘gasè´¹ã€‚æˆ‘è¿˜ä¸çŸ¥é“ä¸€ä¸ªç¡®ä¿æ‰€æœ‰äººä½¿ç”¨æ—¶éƒ½çš„ä¸‡æ— ä¸€å¤±çš„æœºåˆ¶ã€‚ç¡®å®šæ­£ç¡®è´¹ç”¨çš„ç­–ç•¥å¯èƒ½æ¶‰åŠä»èŠ‚ç‚¹æŸ¥è¯¢ä¸gasç›¸å…³çš„ä¿¡æ¯ï¼ˆä¾‹å¦‚ç½‘ç»œæ¥å—çš„æœ€ä½åŸºæœ¬è´¹ç”¨ï¼‰ã€‚

ä¾‹å¦‚ï¼Œåœ¨ä»¥ä¸‹è¯·æ±‚ä¸­ï¼Œä½ å¯ä»¥çœ‹åˆ°Metamaskæµè§ˆå™¨æ‰©å±•åœ¨æ„å»ºäº¤æ˜“æ—¶å‘æœ¬åœ°æµ‹è¯•èŠ‚ç‚¹å‘é€è¯·æ±‚ä»¥è·å–gasè´¹æ•°æ®ï¼š

![å‘èŠ‚ç‚¹æŸ¥è¯¢gasæœ‰å…³æ•°æ®æ—¶çš„Metamaskç½‘ç»œæµé‡](https://notonlyowner.com/images/metamask-gas-traffic.png)

ç®€åŒ–åçš„è¯·æ±‚â€”â€”ç›¸åº”å¦‚ä¸‹ï¼š

`POST / HTTP/1.1 Content-Type: application/json Content-Length: 99  {     "id":3951089899794639,     "jsonrpc":"2.0",     "method":"eth_feeHistory",     "params":["0x1","0x1",[10,20,30]] } --- HTTP/1.1 200 OK Content-Type: application/json Content-Length: 190  {     "jsonrpc":"2.0",     "id":3951089899794639,     "result":{         "oldestBlock":"0x1",         "baseFeePerGas":["0x342770c0","0x2da4d8cd"],         "gasUsedRatio":[0.0007],         "reward":[["0x59682f00","0x59682f00","0x59682f00"]]     } }`

å…¶ä¸­ï¼Œ`eth_feeHistory` ç«¯ç‚¹ç”±ä¸€äº›å…è®¸æŸ¥è¯¢äº¤æ˜“è´¹æ•°æ®èŠ‚ç‚¹å…¬å¼€ã€‚å¦‚æœä½ æ„Ÿå…´è¶£ï¼Œå¯ä»¥åœ¨[è¿™é‡Œ][49]é˜…è¯»æˆ–å°è¯•æ“ä½œ[è¿™ä¸ª][50]ï¼Œæˆ–è€…åœ¨[è¿™é‡Œ][51]æŸ¥çœ‹è§„èŒƒã€‚

çƒ­é—¨é’±åŒ…è¿˜ä½¿ç”¨æ›´å¤æ‚çš„é“¾ä¸‹æœåŠ¡æ¥è·å–gasä»·æ ¼ä¼°ç®—å€¼ä»è€Œå‘ç”¨æˆ·å»ºè®®åˆç†çš„æ•°å€¼ã€‚ä»¥ä¸‹æ˜¯ä¸€ä¸ªé’±åŒ…è®¿é—®ç½‘ç»œæœåŠ¡çš„å…¬å…±ç«¯ç‚¹ï¼Œå¹¶æ¥æ”¶å¤§é‡æœ‰ç”¨çš„ä¸gasç›¸å…³çš„æ•°æ®çš„ç¤ºä¾‹ï¼š

![Wiresharkä¸­åŒ…æ‹¬ä»¥å¤ªåŠå†å²gasè´¹æŸ¥è¯¢è¯·æ±‚çš„ç½‘ç»œæµé‡](https://notonlyowner.com/images/gas-data-requests.png)

è®©æˆ‘ä»¬çœ‹ä¸€ä¸‹å“åº”çš„ç‰‡æ®µï¼š

![Wiresharkä¸­åŒ…æ‹¬ä»¥å¤ªåŠå†å²gasè´¹æŸ¥è¯¢å“åº”çš„ç½‘ç»œæµé‡](https://notonlyowner.com/images/gas-data-response.png)

è¿™å¾ˆé…·ï¼Œå¯¹å§ï¼Ÿ

å¸Œæœ›ä½ å·²ç»å¼€å§‹é€æ¸äº†è§£è®¾å®šgasä»·æ ¼å¹¶ä¸æ˜¯ä¸€ä»¶ç®€å•çš„äº‹æƒ…ï¼Œå¹¶ä¸”è¿™æ˜¯æ„å»ºæˆåŠŸäº¤æ˜“çš„åŸºæœ¬æ­¥éª¤ã€‚å³ä½¿ä½ åªæ˜¯æƒ³å‘é€1ä¸ªDAIã€‚[è¿™][52]æ˜¯ä¸€ä¸ªæœ‰è¶£çš„å…¥é—¨æŒ‡å—ï¼Œå¯ä»¥æ·±å…¥äº†è§£ä¸€äº›æ¶‰åŠæ›´å‡†ç¡®åœ°è®¾ç½®äº¤æ˜“è´¹ç”¨çš„æœºåˆ¶ã€‚

åœ¨äº†è§£åŸºæœ¬èƒŒæ™¯ä¹‹åï¼Œç°åœ¨è®©æˆ‘ä»¬å›åˆ°å®é™…çš„äº¤æ˜“ã€‚æœ‰ä¸‰ä¸ªä¸gasç›¸å…³çš„å­—æ®µéœ€è¦è®¾ç½®ï¼š

`{     "maxPriorityFeePerGas": ...,     "maxFeePerGas": ...,     "gasLimit": ..., }`

é’±åŒ…å°†ä½¿ç”¨å‰é¢æåˆ°çš„æœºåˆ¶æ¥ä¸ºä½ å¡«å……å¥½å‰ä¸¤ä¸ªå­—æ®µã€‚æœ‰è¶£çš„æ˜¯ï¼Œæ¯å½“é’±åŒ…ç”¨æˆ·ç•Œé¢è®©æ‚¨åœ¨â€œæ…¢é€Ÿâ€ã€â€œå¸¸è§„â€æˆ–â€œå¿«é€Ÿâ€äº¤æ˜“ç‰ˆæœ¬ä¹‹é—´è¿›è¡Œé€‰æ‹©æ—¶ï¼Œå®é™…ä¸Šæ˜¯åœ¨å°è¯•å†³å®šå“ªäº›æ•°å€¼æœ€é€‚åˆè¿™äº›å‚æ•°ã€‚ç°åœ¨ä½ å¯ä»¥æ›´å¥½åœ°ç†è§£æˆ‘ä¹‹å‰å±•ç¤ºç»™ä½ çš„é’±åŒ…æ”¶åˆ°çš„JSONæ ¼å¼å“åº”çš„å†…å®¹ã€‚

è¦ç¡®å®šç¬¬ä¸‰ä¸ªå­—æ®µçš„å€¼ï¼Œå³gasé™åˆ¶ï¼Œé’±åŒ…ç”¨ä¸€ä¸ªæ–¹ä¾¿çš„æœºåˆ¶æ¥æ¨¡æ‹Ÿäº¤æ˜“åœ¨å®é™…æäº¤ä¹‹å‰ä¼šæ¶ˆè€—å¤šå°‘gasã€‚è¿™ä½¿å®ƒä»¬èƒ½å¤Ÿè¿‘ä¼¼ä¼°è®¡äº¤æ˜“å°†æ¶ˆè€—å¤šå°‘gasï¼Œä»è€Œè®¾ç½®åˆç†çš„ç‡ƒæ°”é™åˆ¶ï¼Œåœ¨é™¤äº†ä¸ºæ‚¨æä¾›äº¤æ˜“çš„æœ€ç»ˆç¾å…ƒæˆæœ¬ä¼°ç®—ä¹‹å¤–ã€‚

ä¸ºä»€ä¹ˆä¸è®¾ç½®ä¸€ä¸ªæ— é™å¤§çš„gasé™åˆ¶å‘¢ï¼Ÿå½“ç„¶æ˜¯ä¸ºäº†ä¿æŠ¤ä½ çš„èµ„é‡‘ã€‚æ™ºèƒ½åˆçº¦å¯èƒ½å…·æœ‰ä»»æ„é€»è¾‘ï¼Œè€Œä½ æ˜¯ä¸ºå…¶æ‰§è¡Œä»˜è´¹çš„äººã€‚é€šè¿‡åœ¨äº¤æ˜“å¼€å§‹æ—¶é€‰æ‹©åˆç†çš„gasé™åˆ¶ï¼Œæ‚¨å¯ä»¥é˜²æ­¢ä¸è‰¯æƒ…å†µå‘ç”Ÿï¼Œè¿™äº›ä¸è‰¯æƒ…å†µå¯èƒ½ä¼šå¯¼è‡´æ‰€æœ‰æ‚¨è´¦æˆ·ä¸­çš„ä»¥å¤ªå¸èµ„é‡‘è¢«gasè´¹è€—å°½ã€‚

Gas ä¼°ç®—å¯ä»¥ä½¿ç”¨èŠ‚ç‚¹çš„ `eth_estimateGas` ç«¯ç‚¹è¿›è¡Œã€‚åœ¨å‘é€1 DAIä¹‹å‰ï¼Œé’±åŒ…å¯ä»¥åˆ©ç”¨è¿™ç§æœºåˆ¶æ¥æ¨¡æ‹Ÿä½ çš„äº¤æ˜“ï¼Œå¹¶ç¡®å®š DAI è½¬è´¦çš„æ­£ç¡® gas é™åˆ¶ã€‚è¿™æ˜¯é’±åŒ…çš„è¯·æ±‚â€”â€”å“åº”çœ‹èµ·æ¥çš„æ ·å­ã€‚

`POST / HTTP/1.1 Content-Type: application/json  {     "id":2697097754525,     "jsonrpc":"2.0",     "method":"eth_estimateGas",     "params":[         {             "from":"0x6fC27A75d76d8563840691DDE7a947d7f3F179ba",             "value":"0x0",             "data":"0xa9059cbb000000000000000000000000d8da6bf26964af9d7eed9e03e53415d37aa960450000000000000000000000000000000000000000000000000de0b6b3a7640000",             "to":"0x6b175474e89094c44da98b954eedeac495271d0f"         }     ] } --- HTTP/1.1 200 OK Content-Type: application/json  {"jsonrpc":"2.0","id":2697097754525,"result":"0x8792"}`

åœ¨å“åº”ä¸­ï¼Œæ‚¨å¯ä»¥çœ‹åˆ°è½¬è´¦å¤§çº¦éœ€è¦34706ä¸ªå•å…ƒçš„gasã€‚

è®©æˆ‘ä»¬å°†è¿™äº›ä¿¡æ¯åˆå¹¶åˆ°äº¤æ˜“æœ‰æ•ˆè´Ÿè½½ä¸­ï¼š

`{     "to": "0x6b175474e89094c44da98b954eedeac495271d0f",     "amount": 0,     "chainId": 31337,     "nonce": 0,     "data": "0xa9059cbb000000000000000000000000d8da6bf26964af9d7eed9e03e53415d37aa960450000000000000000000000000000000000000000000000000de0b6b3a7640000",     "maxPriorityFeePerGas": 2000000000,     "maxFeePerGas": 120000000000,     "gasLimit": 40000 }`

è¯·è®°ä½ï¼Œ `maxPriorityFeePerGas` å’Œ `maxFeePerGas` æœ€ç»ˆå–å†³äºå‘é€äº¤æ˜“æ—¶çš„ç½‘ç»œæ¡ä»¶ã€‚ä¸Šé¢æˆ‘åªæ˜¯ä¸ºäº†ä¸¾ä¾‹è€Œè®¾ç½®äº†ä¸€äº›ç›¸å¯¹éšæ„çš„å€¼ã€‚è‡³äºgasé™åˆ¶çš„è®¾å®šå€¼ï¼Œæˆ‘åªæ˜¯åœ¨ä¼°ç®—å€¼ä¸Šç¨å¾®å¢åŠ äº†ä¸€äº›ä»¥ç¡®ä¿å®‰å…¨ã€‚

### è®¿é—®æ§åˆ¶åˆ—è¡¨å’Œäº¤æ˜“ç±»å‹

è®©æˆ‘ä»¬ç®€è¦è®¨è®ºä¸€ä¸‹ä½ çš„äº¤æ˜“ä¸­éœ€è¦è®¾ç½®çš„å¦å¤–ä¸¤ä¸ªå­—æ®µã€‚

é¦–å…ˆæ˜¯ `accessList` å­—æ®µã€‚é«˜çº§ä½¿ç”¨åœºæ™¯æˆ–è¾¹ç•Œæƒ…å†µå¯èƒ½éœ€è¦äº‹å…ˆæŒ‡å®šäº¤æ˜“è¦è®¿é—®çš„è´¦æˆ·åœ°å€å’Œåˆçº¦å­˜å‚¨æ§½ï¼Œä»è€Œä½¿å…¶æˆæœ¬ç•¥å¾®é™ä½ã€‚

ç„¶è€Œï¼Œäº‹å…ˆå»ºç«‹è¿™æ ·çš„æ¸…å•å¯èƒ½å¹¶ä¸é‚£ä¹ˆç®€å•ï¼Œç›®å‰çš„gasèŠ‚çœå¯èƒ½å¹¶ä¸é‚£ä¹ˆæ˜¾è‘—ã€‚ç‰¹åˆ«æ˜¯å¯¹äºå‘é€1 DAIè¿™æ ·çš„ç®€å•äº¤æ˜“ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥å°†å…¶è®¾ç½®ä¸ºç©ºåˆ—è¡¨ã€‚ä½†è¦è®°ä½ï¼Œå®ƒç¡®å®æ˜¯æœ‰å…¶[å­˜åœ¨çš„ç†ç”±][53]ï¼Œè€Œä¸”åœ¨æœªæ¥å¯èƒ½å˜å¾—æ›´åŠ é‡è¦ã€‚

ç¬¬äºŒï¼Œ[äº¤æ˜“çš„ç±»å‹][54]ã€‚å®ƒåœ¨ `type` å­—æ®µä¸­æŒ‡å®šã€‚ç±»å‹ç”¨æ¥æŒ‡ç¤ºæ˜¯äº¤æ˜“å†…éƒ¨çš„å†…å®¹çš„ã€‚æˆ‘ä»¬çš„ä¾‹å­å±äºç±»å‹2äº¤æ˜“ï¼Œå› ä¸ºå®ƒéµå¾ª[è¿™é‡Œ][55]æŒ‡å®šçš„æ ¼å¼ã€‚


`{     "to": "0x6b175474e89094c44da98b954eedeac495271d0f",     "amount": 0,     "chainId": 31337,     "nonce": 0,     "data": "0xa9059cbb000000000000000000000000d8da6bf26964af9d7eed9e03e53415d37aa960450000000000000000000000000000000000000000000000000de0b6b3a7640000",     "maxPriorityFeePerGas": 2000000000,     "maxFeePerGas": 120000000000,     "gasLimit": 40000,     "accessList": [],     "type": 2 }`

### å¯¹äº¤æ˜“ç­¾å

èŠ‚ç‚¹å¦‚ä½•çŸ¥é“æ˜¯ _æ‚¨çš„_ è´¦æˆ·è€Œä¸æ˜¯åˆ«äººçš„è´¦æˆ·å‘é€çš„äº¤æ˜“ï¼Ÿ

æˆ‘ä»¬æ¥åˆ°äº†æ„å»ºæœ‰æ•ˆäº¤æ˜“çš„å…³é”®æ­¥éª¤ï¼šå¯¹äº¤æ˜“ç­¾åã€‚

ä¸€æ—¦é’±åŒ…æ”¶é›†åˆ°è¶³å¤Ÿçš„ä¿¡æ¯æ¥æ„å»ºäº¤æ˜“ï¼Œå¹¶ä¸”ä½ ç‚¹å‡»äº†å‘é€ï¼Œå®ƒå°†å¯¹ä½ çš„äº¤æ˜“è¿›è¡Œæ•°å­—ç­¾åã€‚å…·ä½“è¿‡ç¨‹ï¼Ÿä½¿ç”¨ä½ è´¦æˆ·çš„ç§é’¥ï¼ˆä½ çš„é’±åŒ…å¯ä»¥è®¿é—®ï¼‰å’Œä¸€ä¸ªæ¶‰åŠæ¤­åœ†æ›²çº¿çš„åŠ å¯†ç®—æ³•ï¼Œç§°ä¸º [ECDSA][56]ã€‚

æ»¡è¶³ä¸€ä¸‹ä½ çš„å¥½å¥‡å¿ƒï¼Œå®é™…ä¸Šè¢«ç­¾åçš„æ˜¯å°†äº¤æ˜“ç±»å‹å’Œäº¤æ˜“çš„ [RLP ç¼–ç ][57] çš„æ‹¼æ¥èµ·æ¥åå–`keccak256` å“ˆå¸Œ

`keccak256(0x02 || rlp([chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gasLimit, to, amount, data, accessList]))`

ä½ ä¸å¿…å¯¹å¯†ç å­¦æœ‰æ·±å…¥äº†è§£æ‰èƒ½ç†è§£è¿™è¿™ä¸€éƒ¨åˆ†ã€‚ç®€å•æ¥è¯´ï¼Œè¿™ä¸ªè¿‡ç¨‹å°è£…äº†äº¤æ˜“ã€‚å®ƒé€šè¿‡åœ¨äº¤æ˜“ä¸ŠåŠ ä¸Šä¸€ä¸ªåªæœ‰ä½ çš„ç§é’¥æ‰èƒ½äº§ç”Ÿçš„æ™ºèƒ½å°ç« ï¼Œä½¿å…¶å˜å¾—ä¸å¯ç¯¡æ”¹ã€‚ä»ç°åœ¨å¼€å§‹ï¼Œä»»ä½•å¯ä»¥è®¿é—®è¯¥ç­¾åäº¤æ˜“çš„äººï¼ˆä¾‹å¦‚ï¼Œä»¥å¤ªåŠèŠ‚ç‚¹ï¼‰éƒ½å¯ç”¨å¯†ç å­¦éªŒè¯è¿™ä¸ªäº¤æ˜“æ˜¯ä½ çš„è´¦æˆ·äº§ç”Ÿçš„ã€‚

é¡ºä¾¿è¯´ä¸€ä¸‹ï¼šç­¾å _å¹¶ä¸ç­‰åŒäº_ åŠ å¯†ã€‚ä½ çš„äº¤æ˜“å§‹ç»ˆä»¥æ˜æ–‡å½¢å¼å­˜åœ¨ã€‚ä¸€æ—¦å…¬å¼€ï¼Œä»»ä½•äººéƒ½å¯ä»¥çœ‹åˆ°å…¶å†…å®¹ã€‚

å¯¹äº¤æ˜“ç­¾åçš„è¿‡ç¨‹æ¯«æ— æ„å¤–åœ°äº§ç”Ÿäº†ä¸€ä¸ªç­¾åã€‚å®é™…ä¸Šï¼Œè¿™æ˜¯ä¸€å †çœ‹èµ·æ¥å¥‡æ€ªä¸”éš¾ä»¥é˜…è¯»çš„æ•°å€¼ã€‚è¿™äº›æ•°å€¼éšäº¤æ˜“ä¸€èµ·è¢«ä¼ æ’­ï¼Œé€šå¸¸è¢«ç§°ä¸º `v`ã€`r` å’Œ `s`ã€‚å¦‚æœä½ æƒ³æ›´æ·±å…¥åœ°äº†è§£è¿™äº›å®é™…ä»£è¡¨ä»€ä¹ˆï¼Œä»¥åŠå®ƒä»¬åœ¨æ¢å¤ä½ çš„è´¦æˆ·åœ°å€æ–¹é¢çš„é‡è¦æ€§ï¼Œäº’è”ç½‘æ˜¯ä½ çš„å¥½å¸®æ‰‹ã€‚

ä½ å¯ä»¥é€šè¿‡æŸ¥çœ‹ [@ethereumjs/tx][58] è¿™ä¸ªè½¯ä»¶åŒ…æ¥æ›´å¥½åœ°äº†è§£ç­¾åçš„å®ç°æ–¹å¼ã€‚è¿˜å¯ä»¥ä½¿ç”¨ [ethers][59] è¿™æ ·çš„å·¥å…·è¿›è¡Œä¸€äº›å®è·µæ“ä½œã€‚ä½œä¸ºä¸€ä¸ªæå…¶ç®€åŒ–çš„ä¾‹å­ï¼Œå‘é€ 1 DAI çš„äº¤æ˜“ç­¾åå¯èƒ½å¦‚ä¸‹æ‰€ç¤ºï¼š

`const { FeeMarketEIP1559Transaction } = require("@ethereumjs/tx");  const txData = {     to: "0x6b175474e89094c44da98b954eedeac495271d0f",     amount: 0,     chainId: 31337,     nonce: 0,     data: "0xa9059cbb000000000000000000000000d8da6bf26964af9d7eed9e03e53415d37aa960450000000000000000000000000000000000000000000000000de0b6b3a7640000",     maxPriorityFeePerGas: ethers.utils.parseUnits('2', 'gwei').toNumber(),     maxFeePerGas: ethers.utils.parseUnits('120', 'gwei').toNumber(),     gasLimit: 40000,     accessList: [],     type: 2, };  const tx = FeeMarketEIP1559Transaction.fromTxData(txData); const signedTx = tx.sign(Buffer.from(process.env.PRIVATE_KEY, 'hex'));  console.log(signedTx.v.toString('hex')); // 1  console.log(signedTx.r.toString('hex')); // 57d733933b12238a2aeb0069b67c6bc58ca8eb6827547274b3bcf4efdad620a  console.log(signedTx.s.toString('hex')); // e49937ec81db89ce70ebec5e51b839c0949234d8aad8f8b55a877bd78cc293`

ç»“æœå¯¹è±¡å°†ç±»ä¼¼äºï¼š

`{     "to": "0x6b175474e89094c44da98b954eedeac495271d0f",     "amount": 0,     "chainId": 31337,     "nonce": 0,     "data": "0xa9059cbb000000000000000000000000d8da6bf26964af9d7eed9e03e53415d37aa960450000000000000000000000000000000000000000000000000de0b6b3a7640000",     "maxPriorityFeePerGas": 2000000000,     "maxFeePerGas": 120000000000,     "gasLimit": 40000,     "accessList": [],     "type": 2,     "v": 1,     "r": "57d733933b12238a2aeb0069b67c6bc58ca8eb6827547274b3bcf4efdad620a",     "s": "e49937ec81db89ce70ebec5e51b839c0949234d8aad8f8b55a877bd78cc293", }`

### åºåˆ—åŒ–

ä¸‹ä¸€æ­¥æ˜¯å¯¹å·²ç»ç­¾åçš„äº¤æ˜“è¿›è¡Œ _åºåˆ—åŒ–_ ã€‚ä¹Ÿå°±æ˜¯è¦å°†ä¸Šé¢çš„ç¾è§‚æ˜“è¯»çš„å¯¹è±¡ç¼–ç æˆåŸå§‹å­—èŠ‚åºåˆ—ï¼Œä»¥ä¾¿å®ƒå¯ä»¥å‘é€åˆ°ä»¥å¤ªåŠç½‘ç»œå¹¶è¢«æ¥æ”¶èŠ‚ç‚¹ä½¿ç”¨ã€‚

ä»¥å¤ªåŠé€‰æ‹©çš„ç¼–ç æ–¹æ³•ç§°ä¸º [RLP][60]ã€‚äº¤æ˜“çš„ç¼–ç æ–¹å¼å¦‚ä¸‹ï¼š

`0x02 || rlp([chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gasLimit, to, value, data, accessList, v, r, s])`

å…¶ä¸­ï¼Œç¬¬ä¸€ä¸ªå­—èŠ‚æ˜¯äº¤æ˜“ç±»å‹ã€‚

åœ¨å‰é¢çš„ä»£ç ç‰‡æ®µåŸºç¡€ä¸Šï¼Œä½ å®é™…ä¸Šå¯ä»¥çœ‹åˆ°å¯¹åºåˆ—åŒ–åçš„äº¤æ˜“å¦‚ä¸‹ï¼š

`console.log(signedTx.serialize().toString('hex')); // 02f8b1827a69808477359400851bf08eb000829c40946b175474e89094c44da98b954eedeac495271d0f80b844a9059cbb000000000000000000000000d8da6bf26964af9d7eed9e03e53415d37aa960450000000000000000000000000000000000000000000000000de0b6b3a7640000c001a0057d733933b12238a2aeb0069b67c6bc58ca8eb6827547274b3bcf4efdad620a9fe49937ec81db89ce70ebec5e51b839c0949234d8aad8f8b55a877bd78cc293`

è¿™å°±æ˜¯å‘é€ 1 DAI ç»™æˆ‘æœ¬åœ°çš„ä»¥å¤ªåŠä¸»ç½‘å‰¯æœ¬ä¸Šçš„ Vitalik çš„å®é™…æœ‰æ•ˆè½½è·ã€‚

### æäº¤äº¤æ˜“

äº¤æ˜“è¢«æ„å»ºå¥½ã€ç­¾åå®Œæ¯•å¹¶åºåˆ—åŒ–ä¹‹åï¼Œå¿…é¡»è¢«å‘é€åˆ°ä¸€ä¸ªä»¥å¤ªåŠèŠ‚ç‚¹ã€‚

èŠ‚ç‚¹å¯èƒ½å…¬å¼€äº†ä¸€ä¸ªä¾¿äºæ¥æ”¶è¿™ç±»è¯·æ±‚çš„ JSON-RPC ç«¯ç‚¹ã€‚è¿™ä¸ªè¯·æ±‚æ˜¯ `eth_sendRawTransaction`ã€‚è¿™æ˜¯ä¸€ä¸ªé’±åŒ…åœ¨æäº¤äº¤æ˜“æ—¶çš„ç½‘ç»œæµé‡ï¼š

![ä½¿ç”¨ eth_sendRawTransaction æ–¹æ³•å‘é€åŸå§‹äº¤æ˜“çš„ Wireshark æµé‡](https://notonlyowner.com/images/send-raw-transaction.png)

è¯·æ±‚-å“åº”çš„æ€»ç»“å¦‚ä¸‹ï¼š

`POST / HTTP/1.1 Content-Type: application/json Content-Length: 446  {     "id":4264244517200,     "jsonrpc":"2.0",     "method":"eth_sendRawTransaction",     "params":["0x02f8b1827a69808477359400851bf08eb000829c40946b175474e89094c44da98b954eedeac495271d0f80b844a9059cbb000000000000000000000000d8da6bf26964af9d7eed9e03e53415d37aa960450000000000000000000000000000000000000000000000000de0b6b3a7640000c001a0057d733933b12238a2aeb0069b67c6bc58ca8eb6827547274b3bcf4efdad620a9fe49937ec81db89ce70ebec5e51b839c0949234d8aad8f8b55a877bd78cc293"] } --- HTTP/1.1 200 OK Content-Type: application/json Content-Length: 114  {     "jsonrpc":"2.0",     "id":4264244517200,     "result":"0xbf77c4a9590389b0189494aeb2b2d68dc5926a5e20430fb5bc3c610b59db3fb5" }`

å“åº”ç»“æœåŒ…å«äº¤æ˜“çš„å“ˆå¸Œï¼š`bf77c4a9590389b0189494aeb2b2d68dc5926a5e20430fb5bc3c610b59db3fb5`ã€‚è¿™ä¸ªç”±32ä¸ªåå…­è¿›åˆ¶å­—ç¬¦ç»„æˆçš„åºåˆ—æ˜¯æäº¤çš„äº¤æ˜“çš„å”¯ä¸€æ ‡è¯†ç¬¦ã€‚

## æ¥æ”¶äº¤æ˜“

æˆ‘ä»¬åº”è¯¥å¦‚ä½•å»å¼„æ¸…æ¥šä»¥å¤ªåŠèŠ‚ç‚¹åœ¨æ¥æ”¶åºåˆ—åŒ–çš„å·²ç­¾åäº¤æ˜“æ—¶ä¼šå‘ç”Ÿä»€ä¹ˆï¼Ÿ

æœ‰äº›äººå¯èƒ½ä¼šåœ¨ Twitter ä¸Šè¯¢é—®ï¼Œå…¶ä»–äººå¯èƒ½ä¼šé˜…è¯»ä¸€äº› Medium æ–‡ç« ã€‚è¿˜æœ‰äººå¯èƒ½ä¼šé˜…è¯»æ–‡æ¡£ã€‚[çœŸå¯æƒœï¼][61]

åªæœ‰ä¸€ä¸ªåœ°æ–¹å¯ä»¥æ‰¾åˆ°çœŸç›¸ï¼šå°±åœ¨æºå¤´ã€‚è®©æˆ‘ä»¬ä½¿ç”¨ [go-ethereum v1.10.18][62]ï¼ˆå³ Gethï¼‰ï¼Œè¿™æ˜¯ä¸€ä¸ªçƒ­é—¨çš„ä»¥å¤ªåŠèŠ‚ç‚¹å®ç°ï¼ˆä»¥å¤ªåŠè½¬å‘PoSåç§°ä¸ºâ€œæ‰§è¡Œå®¢æˆ·ç«¯â€ï¼‰ã€‚ä»ç°åœ¨å¼€å§‹ï¼Œæˆ‘ä¼šåœ¨åˆé€‚ä½ç½®æ’å…¥æŒ‡å‘ Geth æºä»£ç çš„é“¾æ¥ï¼Œä¾›ä½ è·Ÿè¿›ã€‚

åœ¨[ç«¯ç‚¹][63] æ”¶åˆ°å¯¹`eth_sendRawTransaction` çš„JSON-RPC è°ƒç”¨åï¼ŒèŠ‚ç‚¹éœ€è¦å¼„æ¸…æ¥šè¯·æ±‚æ­£æ–‡ä¸­åŒ…å«çš„åºåˆ—åŒ–äº¤æ˜“ã€‚å› æ­¤ [å®ƒä»ååºåˆ—åŒ–äº¤æ˜“å¼€å§‹][64]ã€‚ä»ç°åœ¨å¼€å§‹ï¼ŒèŠ‚ç‚¹å°†æ›´å®¹æ˜“è®¿é—®åˆ°äº¤æ˜“çš„å­—æ®µã€‚

æ­¤æ—¶ï¼ŒèŠ‚ç‚¹å·²ç»å¼€å§‹éªŒè¯äº¤æ˜“ã€‚[é¦–å…ˆ][65]ï¼Œç¡®ä¿äº¤æ˜“çš„æ‰‹ç»­è´¹ï¼ˆå³ä»·æ ¼ * gasé™åˆ¶ï¼‰ä¸è¶…è¿‡èŠ‚ç‚¹æ„¿æ„æ¥å—çš„æœ€å¤§å€¼ï¼ˆæ˜¾ç„¶ï¼Œ[é»˜è®¤æƒ…å†µä¸‹è¿™æ˜¯ 1 ä»¥å¤ªå¸][66]ï¼‰ã€‚[æ¥ç€][67]ï¼Œç¡®ä¿äº¤æ˜“å…·æœ‰é‡æ”¾ä¿æŠ¤ï¼ˆéµå¾ª [EIP 155][68] - è®°å¾—æˆ‘ä»¬åœ¨äº¤æ˜“ä¸­è®¾ç½®çš„ `chainID` å­—æ®µï¼Ÿï¼‰ï¼Œæˆ–è€…èŠ‚ç‚¹æ„¿æ„æ¥å—æœªå—ä¿æŠ¤çš„äº¤æ˜“ã€‚

æ¥ä¸‹æ¥çš„æ­¥éª¤åŒ…æ‹¬ [å‘é€][69] [äº¤][70] [æ˜“][71] [åˆ°][72] [äº¤æ˜“æ± ][73]ï¼ˆå³å†…å­˜æ± ï¼‰ã€‚ç®€å•æ¥è¯´ï¼Œè¿™ä¸ªæ± ä»£è¡¨äº†èŠ‚ç‚¹åœ¨ç‰¹å®šæ—¶åˆ»æ‰€çŸ¥é“çš„äº¤æ˜“é›†åˆã€‚å°±èŠ‚ç‚¹æ‰€çŸ¥ï¼Œè¿™äº›äº¤æ˜“éƒ½è¿˜æ²¡ä¸Šé“¾ã€‚

åœ¨ _çœŸæ­£_ å°†äº¤æ˜“åŠ å…¥åˆ°äº¤æ˜“æ± ä¹‹å‰ï¼ŒèŠ‚ç‚¹ä¼š[æ£€æŸ¥][74]è‡ªå·±æ˜¯å¦å·²ç»çŸ¥é“è¿™ä¸ªäº¤æ˜“ï¼Œä»¥åŠè¿™ä¸ªäº¤æ˜“çš„ ECDSA ç­¾åæ˜¯å¦ [æœ‰æ•ˆ][75]ã€‚å¦åˆ™å°†ä¸¢å¼ƒäº¤æ˜“ã€‚

ç„¶åå¼€å§‹[å¤„ç†ç¹é‡çš„å†…å­˜æ± å·¥ä½œ][76]ã€‚æ­£å¦‚ä½ å¯èƒ½æ³¨æ„åˆ°çš„ï¼Œæœ‰å¾ˆå¤šæ„ä¹‰éå‡¡çš„é€»è¾‘ä»¥ç¡®ä¿äº¤æ˜“æ± ä¿æŒå¿«ä¹å’Œå¥åº·ã€‚

è¿™é‡Œè¿›è¡Œäº†ç›¸å½“å¤šçš„é‡è¦ [éªŒè¯][77]ã€‚ä¾‹å¦‚gasé™åˆ¶ [ä½äºåŒºå—gasé™åˆ¶][78]ï¼Œæˆ–äº¤æ˜“çš„å¤§å° [ä¸è¶…è¿‡][79] [å…è®¸çš„æœ€å¤§å€¼][80]ï¼Œæˆ– nonce æ˜¯ [é¢„æœŸçš„][81]ï¼Œæˆ–å‘é€è€…æœ‰ [è¶³å¤Ÿçš„èµ„é‡‘][82] æ¥æ”¯ä»˜æ½œåœ¨æˆæœ¬ï¼ˆå³ä»·å€¼ + gasé™åˆ¶ * ä»·æ ¼ï¼‰ï¼Œç­‰ç­‰ã€‚

è™½ç„¶æˆ‘ä»¬å¯ä»¥ç»§ç»­ï¼Œä½†æˆ‘ä»¬ä¸åœ¨è¿™é‡Œæˆä¸ºå†…å­˜æ± ä¸“å®¶ã€‚å³ä½¿æˆ‘ä»¬æƒ³æˆä¸ºï¼Œæˆ‘ä»¬ä¹Ÿéœ€è¦è€ƒè™‘åˆ°ï¼Œåªè¦ä»–ä»¬éµå¾ªç½‘ç»œå…±è¯†è§„åˆ™ï¼Œæ¯ä¸ªèŠ‚ç‚¹æ“ä½œè€…å¯èƒ½ä¼šé‡‡å–ä¸åŒçš„å†…å­˜æ± ç®¡ç†æ–¹æ³•ï¼Œä»–ä»¬å¯èƒ½ä¼šæ‰§è¡Œç‰¹æ®ŠéªŒè¯æˆ–éµå¾ªè‡ªå®šä¹‰äº¤æ˜“ä¼˜å…ˆçº§è§„åˆ™ã€‚åœ¨æœ¬æ¡ˆä¾‹ä¸­ï¼Œæˆ‘ä»¬åªæ˜¯è¦å‘é€ 1 DAIï¼Œæˆ‘ä»¬å¯ä»¥å°†å†…å­˜æ± è§†ä¸ºä¸€ç»„æ€¥åˆ‡ç­‰å¾…è¢«æŒ‘é€‰å¹¶åŒ…å«åœ¨åŒºå—ä¸­çš„äº¤æ˜“ã€‚

æˆåŠŸå°†äº¤æ˜“å…¥æ±  (å¹¶è¿›è¡Œå†…éƒ¨ [æ—¥å¿—][83] è®°å½•)ä¹‹å,ï¼ŒèŠ‚ç‚¹ä¼š [è¿”å›äº¤æ˜“å“ˆå¸Œå€¼][84]. è¿™æ­£æ˜¯æˆ‘ä»¬ä¹‹å‰åœ¨JSON-RPCçš„ è¯·æ±‚â€”â€”å“åº” ä¸­çœ‹åˆ°çš„è¿”å›ç»“æœ ğŸ˜

### æ£€æŸ¥å†…å­˜æ± 

å¦‚æœä½ é€šè¿‡ Metamask æˆ–ä»»ä½•é»˜è®¤æƒ…å†µä¸‹ä¼šè¿æ¥åˆ°ä¼ ç»ŸèŠ‚ç‚¹çš„é’±åŒ…å‘é€äº¤æ˜“ï¼Œäº¤æ˜“æœ€ç»ˆä¼šè¿›å…¥å…¬å…±èŠ‚ç‚¹çš„å†…å­˜æ± ã€‚ä½ å¯ä»¥è‡ªå·±æ£€æŸ¥å†…å­˜æ± æ¥ç¡®è®¤è¿™ä¸€ç‚¹ã€‚

æœ‰äº›èŠ‚ç‚¹ä¼šå…¬å¼€ä¸€ä¸ªæ–¹ä¾¿æ¥å…¥çš„ç«¯ç‚¹ï¼Œå«åš `eth_newPendingTransactionFilter`ã€‚å¯èƒ½æ˜¯[æŠ¢å…ˆäº¤æ˜“][85][æœºå™¨äºº][86]çš„è€æœ‹å‹äº†ã€‚å®šæœŸæŸ¥è¯¢è¿™ä¸ªç«¯ç‚¹åº”è¯¥å¯ä»¥è®©æˆ‘ä»¬è§‚å¯Ÿåˆ°ï¼Œåœ¨äº¤æ˜“è¢«æ‰“åŒ…è¿›åŒºå—ä¹‹å‰ï¼Œè¦å‘é€ 1 DAI çš„äº¤æ˜“è¿›å…¥äº†æœ¬åœ°æµ‹è¯•èŠ‚ç‚¹çš„å†…å­˜æ± ã€‚

åœ¨ Javascript ä»£ç ä¸­ï¼Œå¯ä»¥è¿™æ ·å®ç°:

```js
const hre = require("hardhat");
hre.ethers.provider.on('pending', async function (tx)
{
    // å¯¹äº¤æ˜“åšä¸€äº›å¤„ç†
});
```

è¦æŸ¥çœ‹å®é™…çš„ `eth_newPendingTransactionFilter` è°ƒç”¨ï¼Œæˆ‘ä»¬åªéœ€æ£€æŸ¥ç½‘ç»œæµé‡:

![æŸ¥çœ‹ pending äº¤æ˜“çš„ JSON-RPC è°ƒç”¨çš„ Wireshark æµé‡]()

ä»ç°åœ¨å¼€å§‹ï¼Œè¿™ä¸ªè„šæœ¬ä¼š(è‡ªåŠ¨åœ°)æŸ¥è¯¢å†…å­˜æ± çš„å˜åŒ–ã€‚ä»¥ä¸‹æ˜¯éšåè®¸å¤šä¸ªå®šæœŸæŸ¥è¯¢æ›´æ”¹çš„è¯·æ±‚ä¸­çš„é¦–æ¬¡è¯·æ±‚ï¼š

![è¯·æ±‚å†…å­˜æ± å˜åŒ–çš„ JSON-RPC è°ƒç”¨çš„ Wireshark æµé‡]()

åœ¨æ¥æ”¶åˆ°äº¤æ˜“åï¼ŒèŠ‚ç‚¹æœ€ç»ˆä¼šä»¥äº¤æ˜“å“ˆå¸Œä½œå‡ºå›åº”ï¼š

![ä½¿ç”¨æŸ¥è¯¢åˆ°çš„äº¤æ˜“å“ˆå¸Œä½œä¸ºåº”ç­”çš„ JSON-RPC è°ƒç”¨çš„ Wireshark æµé‡]()

æ€»ç»“åè¯·æ±‚â€”â€”å“åº”å¦‚ä¸‹:

```http
POST / HTTP/1.1
Content-Type: application/json
content-length: 74
{
    "jsonrpc":"2.0",
    "method":"eth_getFilterChanges",
    "params":["0x1"],
    "id":58
}
```

```http
HTTP/1.1 200 OK
Content-Type: application/json
Content-Length: 105

{
    "jsonrpc":"2.0",
    "id":58,
    "result":["0xbf77c4a9590389b0189494aeb2b2d68dc5926a5e20430fb5bc3c610b59db3fb5"]
}
```

ä¹‹å‰æˆ‘æåˆ°äº†â€œä¼ ç»ŸèŠ‚ç‚¹â€ï¼Œä½†æ²¡æœ‰å¤šåŠ è§£é‡Šã€‚æˆ‘çš„æ„æ€æ˜¯ï¼Œè¿˜æœ‰[æ›´ä¸“ä¸šçš„èŠ‚ç‚¹][87]ï¼Œå®ƒä»¬æœ‰ç§æœ‰å†…å­˜æ± çš„åŠŸèƒ½ã€‚å®ƒä»¬å…è®¸ç”¨æˆ·åœ¨äº¤æ˜“è¢«æ‰“åŒ…è¿›åŒºå—ä¹‹å‰"éšè—"äº¤æ˜“ã€‚

æ— è®ºå…·ä½“ç»†èŠ‚å¦‚ä½•ï¼Œè¿™ç§æœºåˆ¶é€šå¸¸åŒ…æ‹¬åœ¨äº¤æ˜“å‘é€è€…å’Œæ‰“åŒ…åŒºå—çš„äººä¹‹é—´å»ºç«‹ç§æœ‰é€šé“ã€‚[Flashbots Protect æœåŠ¡][88]å°±æ˜¯ä¸€ä¸ªè‘—åçš„ä¾‹å­ã€‚å®é™…ç»“æœå°±æ˜¯ï¼Œå³ä½¿ä½ ç”¨ä¸Šé¢å±•ç¤ºçš„æ–¹æ³•ç›‘æ§å†…å­˜æ± ï¼Œä¹Ÿæ— æ³•è·å–é€šè¿‡ç§æœ‰é€šé“å‘é€ç»™åŒºå—æ‰“åŒ…è€…çš„äº¤æ˜“ã€‚

æˆ‘ä»¬åœ¨è¿™é‡Œå‡è®¾å‘é€ 1 DAI çš„äº¤æ˜“æ˜¯é€šè¿‡æ™®é€šæ¸ é“æäº¤åˆ°ç½‘ç»œçš„ï¼Œæ²¡æœ‰åˆ©ç”¨è¿™ç±»æœåŠ¡ã€‚

## ä¼ æ’­

è¦è®©äº¤æ˜“è¢«æ‰“åŒ…è¿›åŒºå—ï¼Œå®ƒéœ€è¦ä»¥æŸç§æ–¹å¼åˆ°è¾¾èƒ½å¤Ÿæ„å»ºå®ƒå¹¶æäº¤å®ƒçš„èŠ‚ç‚¹å“ªé‡Œã€‚åœ¨[å·¥ä½œé‡è¯æ˜PoW][89]ä»¥å¤ªåŠä¸­ï¼Œè¿™äº›èŠ‚ç‚¹å«çŸ¿å·¥ã€‚åœ¨[æƒç›Šè¯æ˜PoS][90]ä»¥å¤ªåŠä¸­ï¼Œè¿™äº›èŠ‚ç‚¹å«éªŒè¯è€…ã€‚ä¸è¿‡ç°å®å¾€å¾€æ›´å¤æ‚ä¸€äº›ã€‚è¦çŸ¥é“[åŒºå—çš„æ„å»ºå¯èƒ½ä¼šè¢«å¤–åŒ…][91]ç»™ä¸“é—¨çš„æœåŠ¡ã€‚

ä½œä¸ºæ™®é€šç”¨æˆ·ï¼Œä½ ä¸éœ€è¦çŸ¥é“è¿™äº›åŒºå—çš„ç”Ÿäº§è€…æ˜¯è°ï¼Œä¹Ÿä¸éœ€è¦çŸ¥é“ä»–ä»¬åœ¨å“ªé‡Œã€‚ç›¸åï¼Œä½ å¯ä»¥ç®€å•åœ°æŠŠä¸€ç¬”æœ‰æ•ˆäº¤æ˜“å‘é€ç»™ç½‘ç»œä¸­çš„ä»»æ„ä¸€ä¸ªæ™®é€šèŠ‚ç‚¹ï¼Œè®©å®ƒæŠŠè¿™ä¸ªäº¤æ˜“åŠ å…¥äº¤æ˜“æ± ï¼Œç„¶åè®©P2Påè®®å®Œæˆå‰©ä¸‹çš„å·¥ä½œã€‚

æœ‰[ä¸€ç³»åˆ—P2Påè®®][92]è®©ä»¥å¤ªåŠçš„èŠ‚ç‚¹ä¹‹é—´äº’ç›¸è¿æ¥ã€‚é™¤æ­¤ä¹‹å¤–ï¼Œå®ƒä»¬è¿˜å¯ä»¥é¢‘ç¹åœ°[äº¤æ¢äº¤æ˜“][93]ã€‚

ä»ä¸€å¼€å§‹ï¼Œæ‰€æœ‰èŠ‚ç‚¹å°±åœ¨[ç›‘å¬å¹¶å‘å®ƒä»¬çš„å¯¹ç­‰èŠ‚ç‚¹å¹¿æ’­][94]äº¤æ˜“(é»˜è®¤æœ€å¤š[50 ä¸ªå¯¹ç­‰èŠ‚ç‚¹][95])ã€‚

ä¸€æ—¦ä¸€ç¬”äº¤æ˜“åˆ°è¾¾å†…å­˜æ± ï¼Œå®ƒå°±ä¼š[è¢«å‘é€ç»™æ‰€æœ‰è¿˜ä¸çŸ¥é“è¿™ç¬”äº¤æ˜“çš„å·²è¿æ¥å¯¹ç­‰èŠ‚ç‚¹][96]ã€‚

ä¸ºäº†æé«˜æ•ˆç‡ï¼Œåªæœ‰ä¸€ä¸ªå·²è¿æ¥èŠ‚ç‚¹çš„éšæœºå­é›†([å¹³æ–¹æ ¹æ•°é‡çº§][97] ğŸ¤“)ä¼š[æ”¶åˆ°å®Œæ•´çš„äº¤æ˜“][98]ã€‚å…¶ä½™çš„èŠ‚ç‚¹[åªä¼šæ”¶åˆ°äº¤æ˜“å“ˆå¸Œ][99]ã€‚è¿™äº›èŠ‚ç‚¹å¯ä»¥åœ¨éœ€è¦æ—¶è¯·æ±‚å®Œæ•´çš„äº¤æ˜“ä¿¡æ¯ã€‚

ä¸€ç¬”äº¤æ˜“ä¸èƒ½æ°¸è¿œåœç•™åœ¨èŠ‚ç‚¹çš„å†…å­˜æ± ä¸­ã€‚å¦‚æœå®ƒæ²¡æœ‰å› ä¸ºå…¶ä»–åŸå› å…ˆè¢«ä¸¢å¼ƒ(ä¾‹å¦‚ï¼Œäº¤æ˜“æ± æ»¡äº†ã€äº¤æ˜“çš„ gas å®šä»·å¤ªä½ï¼Œæˆ–è€…å®ƒè¢«ä¸€ä¸ª nonce/price æ›´é«˜çš„æ–°äº¤æ˜“æ›¿æ¢)ï¼Œå®ƒå¯èƒ½ä¼šåœ¨ä¸€æ®µæ—¶é—´åè‡ªåŠ¨[è¢«ç§»é™¤][100](é»˜è®¤å€¼ä¸º[3 å°æ—¶][101])ã€‚

å†…å­˜æ± ä¸­è¢«åŒºå—ç”Ÿäº§è€…è®¤ä¸ºå·²ç»å‡†å¤‡å¥½è¢«æå–å’Œå¤„ç†çš„æœ‰æ•ˆäº¤æ˜“ä¼šè¢«[è·Ÿè¸ª][102]åœ¨ä¸€ä¸ª[å¾…å¤„ç†äº¤æ˜“][103]åˆ—è¡¨ä¸­ã€‚åŒºå—ç”Ÿäº§è€…å¯ä»¥[æŸ¥è¯¢][104]è¿™ä¸ªæ•°æ®ç»“æ„ï¼Œè·å–å…è®¸è¢«æ‰“åŒ…ä¸Šé“¾çš„å¯å¤„ç†äº¤æ˜“ã€‚

## å‡†å¤‡å·¥ä½œå’Œäº¤æ˜“æ‰“åŒ…

äº¤æ˜“åœ¨éå†å†…å­˜æ± ååº”è¯¥ä¼šåˆ°è¾¾ä¸€ä¸ªæŒ–çŸ¿èŠ‚ç‚¹(è‡³å°‘åœ¨æ’°å†™æœ¬æ–‡æ—¶æ˜¯è¿™æ ·)ã€‚è¿™ç±»èŠ‚ç‚¹åœ¨å¤šä»»åŠ¡å¤„ç†æ–¹é¢è¡¨ç°å¾—å°¤å…¶å‡ºè‰²ã€‚å¯¹äºç†Ÿæ‚‰ Golang çš„äººæ¥è¯´ï¼Œè¿™æ„å‘³ç€åœ¨æŒ–çŸ¿ç›¸å…³çš„é€»è¾‘ä¸­ä¼šæœ‰ç›¸å½“å¤šçš„ go routine å’Œ channelã€‚å¯¹äºä¸ç†Ÿæ‚‰ Golang çš„äººæ¥è¯´ï¼Œè¿™æ„å‘³ç€çŸ¿å·¥çš„å¸¸è§„æ“ä½œæ— æ³•åƒæˆ‘å¸Œæœ›çš„é‚£æ ·ç®€å•çš„è§£é‡Šã€‚

è¿™ä¸€èŠ‚æœ‰ä¸¤ä¸ªç›®æ ‡ã€‚é¦–å…ˆï¼Œç†è§£æˆ‘ä»¬çš„äº¤æ˜“å¦‚ä½•ä»¥åŠä½•æ—¶ä»å†…å­˜æ± ä¸­è¢«çŸ¿å·¥æå–ã€‚å…¶æ¬¡ï¼Œæ‰¾å‡ºäº¤æ˜“çš„æ‰§è¡Œä»å“ªä¸ªç‚¹å¼€å§‹ã€‚

å½“èŠ‚ç‚¹çš„æŒ–çŸ¿ç»„ä»¶è¢«åˆå§‹åŒ–æ—¶ï¼Œè‡³å°‘ä¼šå‘ç”Ÿä¸¤ä»¶ç›¸å…³çš„äº‹æƒ…ã€‚ä¸€æ˜¯å®ƒ[å¼€å§‹ç›‘å¬][105]æ–°äº¤æ˜“è¿›å…¥å†…å­˜æ± çš„æƒ…å†µï¼›äºŒæ˜¯è§¦å‘[ä¸€äº›åŸºæœ¬å¾ªç¯][106]ã€‚

ç”¨ Geth çš„â€œè¡Œè¯â€æ¥è¯´ï¼Œæ„å»ºä¸€ä¸ªåŒ…å«äº¤æ˜“çš„åŒºå—å¹¶å°è£…å®ƒçš„è¡Œä¸ºå«åš"æäº¤å·¥ä½œ"ã€‚å› æ­¤æˆ‘ä»¬æƒ³ç†è§£åœ¨ä»€ä¹ˆæƒ…å†µä¸‹ä¼šè§¦å‘æäº¤ã€‚

è®©æˆ‘ä»¬å…³æ³¨ä¸€ä¸‹["new work"å¾ªç¯][107]ã€‚é‚£æ˜¯ä¸€ä¸ªç‹¬ç«‹çš„åç¨‹ï¼Œå½“èŠ‚ç‚¹æ”¶åˆ°[ä¸åŒç±»å‹çš„é€šçŸ¥][108]æ—¶ï¼Œå®ƒä¼šè§¦å‘å·¥ä½œçš„æäº¤ã€‚è§¦å‘å®è´¨ä¸Šæ„å‘³ç€[å°†ä¸€äº›å·¥ä½œå¤„ç†éœ€æ±‚å‘é€][109]åˆ°èŠ‚ç‚¹å¦ä¸€ä¸ªæ´»è·ƒçš„ç›‘å¬å™¨ä¸Š(åœ¨çŸ¿å·¥çš„["main"å¾ªç¯][110]ä¸­è¿è¡Œ)ã€‚ä¸€æ—¦å—åˆ°è¿™æ ·çš„å¤„ç†éœ€æ±‚ï¼Œ[å·¥ä½œçš„æäº¤å°±å¼€å§‹äº†][112]ã€‚

èŠ‚ç‚¹ä»ä¸€äº›[åˆå§‹å‡†å¤‡][113]å¼€å§‹ã€‚ä¸»è¦åŒ…æ‹¬æ„å»ºåŒºå—å¤´ã€‚è¿™åŒ…æ‹¬ä¸€äº›ä»»åŠ¡ï¼Œæ¯”å¦‚[æ‰¾åˆ°çˆ¶åŒºå—][114]ï¼Œç¡®ä¿[æ­£åœ¨æ„å»ºçš„åŒºå—çš„æ—¶é—´æˆ³][115]æ­£ç¡®ï¼Œ[è®¾ç½®å—é«˜][116]ï¼Œ[gas é™åˆ¶][117]ï¼Œ[coinbase åœ°å€][118]å’Œ[åŸºç¡€è´¹ç”¨][119]ã€‚

ä¹‹åï¼Œå…±è¯†å¼•æ“è¢«è°ƒç”¨æ¥ä¸ºåŒºå—å¤´åš["å…±è¯†å‡†å¤‡"][120]ã€‚è¿™ä¼š[è®¡ç®—æ­£ç¡®çš„åŒºå—éš¾åº¦][121]([å–å†³äº][122]ç½‘ç»œçš„å½“å‰ç‰ˆæœ¬)ã€‚å¦‚æœä½ å¬è¯´è¿‡ä»¥å¤ªåŠçš„"éš¾åº¦ç‚¸å¼¹"ï¼Œå°±åœ¨é‚£é‡Œã€‚

æ¥ä¸‹æ¥[åˆ›å»º][123]åŒºå—æ‰“åŒ…æ‰€éœ€çš„ä¸Šä¸‹æ–‡ã€‚é™¤æ­¤ä¹‹å¤–çš„å…¶ä»–æ“ä½œï¼Œè¿™åŒ…æ‹¬[è·å–æœ€æ–°å·²çŸ¥çš„çŠ¶æ€][124]ã€‚è¿™æ˜¯æ­£åœ¨æ„å»ºçš„åŒºå—ä¸­çš„ç¬¬ä¸€ç¬”äº¤æ˜“å°†åœ¨å…¶ä¸Šæ‰§è¡Œçš„çŠ¶æ€ã€‚é‚£å¯èƒ½å°±æ˜¯æˆ‘ä»¬å‘é€ 1 DAI çš„äº¤æ˜“ã€‚

åœ¨å‡†å¤‡å¥½åŒºå—åï¼Œç°åœ¨ç”¨äº¤æ˜“æ¥[å¡«å……å®ƒ][125]ã€‚

æˆ‘ä»¬ç»ˆäºåˆ°äº†è¿™æ ·ä¸€ä¸ªç‚¹ï¼Œæˆ‘ä»¬çš„å¾…å¤„ç†äº¤æ˜“ï¼Œè¿„ä»Šä¸ºæ­¢åªæ˜¯èˆ’é€‚åœ°åœç•™åœ¨èŠ‚ç‚¹çš„å†…å­˜æ± ä¸­ï¼Œç°åœ¨è¢«ä¸å…¶ä»–äº¤æ˜“ä¸€èµ·[å–å‡ºæ¥å¤„ç†][126]ã€‚

é»˜è®¤æƒ…å†µä¸‹ï¼ŒåŒºå—å†…çš„[äº¤æ˜“æ˜¯æŒ‰ gas ä»·æ ¼ å’Œ nonce æ’åºçš„][127]ã€‚åœ¨æœ¬ä¾‹ä¸­ï¼Œäº¤æ˜“åœ¨åŒºå—å†…çš„ä½ç½®å®é™…ä¸Šæ— å…³ç´§è¦ã€‚

ç°åœ¨è¿™äº›äº¤æ˜“çš„[é¡ºåºæ‰§è¡Œ][128]å¼€å§‹äº†ã€‚æ¯ä¸€ç¬”äº¤æ˜“éƒ½åœ¨å‰ä¸€ç¬”çš„ç»“æœçŠ¶æ€ä¹‹ä¸Š[è¢«æ‰§è¡Œ][129]ã€‚

## Execution

An Ethereum transaction can be thought of as a state transition.

State 0: you have 100 DAI, and Vitalik has 100 as well.

Transaction: you send 1 DAI to Vitalik.

State 1: you have 99 DAI, and Vitalik has 101.

Hence, executing a transaction entails _applying_ a sequence of operations to the current state of the blockchain. Producing a new (different) state as a result. This will be considered the new current state until a another transaction comes in.

In reality this is _far_ more interesting (and complex). Let's see.

### Preparation (part 1)

In Geth's jargon, miners [_commit_ transactions][130] in the block. The act of committing a transaction is done in an [_environment_][131]. Such environment contains, among other things, a given [_state_][132].

So in short, committing a transaction is essentially: [(1)][133] remembering the current state, [(2)][134] modifying it by applying the transaction, [(3)][135] depending on the transaction's success, either accepting the new state or rolling back to the original one.

The juicy stuff happens in (2): [applying the transaction][136].

First thing to notice is that [the transaction is turned into a "message"][137]. If you're familiar with Solidity, where you are usually writing things like `msg.data` or `msg.sender`, finally reading "message" in Geth's code is THE sign on the road welcoming you into friendly lands.

Inspecting [what a message looks like][138] quickly leads to notice at least one difference with the transaction. A message has [a `from` field][139]! This field is the signer's Ethereum address, which is [derived][140] from [the public signature][141] included in the transaction (remember the weird `v`, `r` and `s` fields?).

Now the environment for execution [is further prepared][142]. First, the [block-related context is created][143], which includes stuff like block number, timestamp, the coinbase address and the block gas limit. And then...

[the beast walks in][144].

The Ethereum Virtual Machine (EVM), the [stack-based][145] [256-bit][146] computing engine in charge of executing the transaction, shows up all chill like everything is cool man, cool, and [starts putting some clothes on][147]. Yeap, it was naked. It's the EVM, what were you expecting?

The EVM is a machine. And as a machine, it has a set of instructions (a.k.a. opcodes) it can execute. The instruction set has changed over the years. So _there has to be_ some piece of code telling the EVM which opcodes it should use today. And behold, there is. When the EVM [instances its interpreter][148], it [chooses the correct set of opcodes][149], depending on the version being used.

Lastly, [two final steps][150] prior to [real execution][151]. The EVM's transaction context is created (ever used `tx.origin` or `tx.gasPrice` in your Solidity smart contracts?), and the EVM is given access to the current state.

### Preparation (part 2)

It's turn for the EVM to perform the [state transition][152]. Given a message, an environment and the original state, it will use a limited set of instructions to move to a new state. One in which Vitalik has 1 additional DAI ğŸ’°.

Before applying the state transition, the EVM must make sure that it abides to [specific consensus rules][153]. Let's see how that's done in detail.

Validation begins in what Geth calls [the "pre-check"][154]. It consists of:

1.  Validating the message's nonce. It [must match][155] the nonce of the message's `from` address. Also, it [must not be the maximum possible nonce][156] (by checking whether incrementing the nonce by one causes an overflow).
2.  Making sure that the account corresponding to the message's `from` address [does not have code][157]. That is, that the transaction origin is an externally-owned account (EOA). Thus abiding by the [EIP 3607][158] spec.
3.  Validating that the `maxFeePerGas` (the `gasFeeCap` in Geth) and `maxPriorityFeePerGas` (the `gasTipCap` in Geth) fields set in the transaction are [within expected bounds][159]. Moreover, that the priority fee [is not greater][160] than the max fee. And that the `maxFeePerGas` [is greater][161] than the current block's base fee.
4.  [Buying gas][162]. In turn checking that the account [can pay][163] for all the gas it intends to consume. And that there's [enough gas left][164] in the block to process the transaction. Finally making the account [pay in advance][165] for the gas (don't worry, there're refund mechanisms later).

Next, the EVM [accounts for the "intrinsic gas"][166] that the transaction consumes. There are a few factors to consider when calculating intrinsic gas. For starters, [whether the transaction is a contract creation][167]. Ours is not, so the gas starts at [21000 units][168]. Afterwards, the [amount of non-zero bytes][169] in the message's `data` field is also taken into consideration. [16 units][170] are charged per non-zero byte (following [this specification][171]). Only [4 units][172] are charged for each zero byte. Finally, some more gas would be accounted in advance [if we provided access lists][173].

We set the `value` field of the transaction to zero. Had we specified a positive value, now would be the moment for the EVM to check [whether the sender account actually has enough balance][174] to execute the ETH transfer. Furthermore, had we set access lists, [now they would be initialized in state][175].

The transaction being executed is not creating a contract. The EVM knows it [because the `to` field is not zero][176]. Therefore, it will already [increment][177] the sender's account nonce by one, and [execute a call][178].

The call will go from the `from` to the `to` message's addresses, passing along the `data`, no value, and whatever remaining gas is left after consuming the intrinsic gas.

### The call

(not [this call][179])

The DAI smart contract is stored at address `0x6b175474e89094c44da98b954eedeac495271d0f`. That's the address we set in the `to` field of the transaction. This initial call is meant for the EVM to execute whatever code is stored at it. Opcode by opcode.

Opcodes are EVM instructions represented with hex numbers ranging from 00 to FF. Though they're usually referred to with their names. For example, `00` is `STOP` and `FF` is `SELFDESTRUCT`. A handy list of opcodes is available at [evm.codes][180].

So what are DAI's opcodes anyway ? Glad you asked:

![EVM opcodes of the DAI smart contract](https://notonlyowner.com/images/DAI-opcodes.png)

Don't panic. It's still early to make sense out of all of that.

Let's start slowly, tearing [the initial call][181] apart. Its [brief docs][182] provide a good summary:

`// Call executes the contract associated with the addr with the given input as // parameters. It also handles any necessary value transfer required and takes // the necessary steps to create accounts and reverses the state in case of an // execution error or failed value transfer. func (evm *EVM) Call(caller ContractRef, addr common.Address, input []byte, gas uint64, value *big.Int) (ret []byte, leftOverGas uint64, err error) {     ... }`

To begin with, the logic [checks][183] that the call depth limit hasn't been reached. This limit is [set to 1024][184], which means there can only be a maximum of 1024 nested calls in a single transaction. [Here][185] is an interesting article to read about some of the reasoning and subtleties behind this behavior of the EVM. Later we'll explore how the call depth is increased/decreased.

Relevant side note: the call depth limit is _not_ the EVM's stack size limit - which (coincidentally?) [is 1024 elements][186] as well.

The next step is to [make sure][187] that if a positive value was specified in the call, the sender has enough balance to execute the transfer ([performed][188] a few steps later). We can ignore this because our call has zero value. Additionally, a [snapshot of the current state][189] is taken. This allows [easily reverting][190] any state changes upon failure.

We know that DAI's address refers to an account that has code. Thus, it [must already exist][191] in Ethereum's state.

However, let's imagine for a moment this was not a transaction to send 1 DAI. Say it was a trivial transaction with no value targetting a new address. The corresponding account would need to be [_added_ to the state][192]. However, what if said account would end up being just empty ? There doesn't seem to be a reason to keep track of it - other than wasting nodes' disk space. [EIP 158][193] introduced some changes to the Ethereum protocol to help avoid such scenarios. That's why you're seeing [this `if` clause][194] when calling any account.

Another thing we know is that DAI [is _not_ a precompile contract][195]. What's a precompiled contract ? Here's what the [Ethereum yellow paper][196] has to offer:

> \[...\] preliminary piece of architecture that may later become native extensions. The contracts in addresses 1 to 9 execute the elliptic curve public key recovery function, the SHA2 256-bit hash scheme, the RIPEMD 160-bit hash scheme, the identity function, arbitrary precision modular exponentiation, elliptic curve addition, elliptic curve scalar multiplication, an elliptic curve pairing check, and the BLAKE2 compression function F respectively.

In short, there're (so far) 9 different special contracts in Ethereum's state. These accounts (ranging from [0x0000000000000000000000000000000000000001][197] to [0x0000000000000000000000000000000000000009][198]) out-of-the-box include the necessary code to execute the operations mentioned in the yellow paper. Of course, you can [check this by yourself in Geth's code][199].

To add some color to the story of precompiled contracts, note that in Ethereum mainnet all these accounts have _at least_ 1 wei in balance. This was done [intentionally][200] (at least before users started sending Ether by mistake). Look, [here's an almost 5-year-old transaction][201] sending 1 wei to the `0x0000000000000000000000000000000000000009` precompile.

Anyway. Having realized the call's target address does not correspond to a precompiled contract, the node [reads the account's code][202] from the state. Then [ensures it's non-empty][203]. At last, [orders the EVM][204] to use its interpreter to run the code with the given input (the contents of the transaction's `data` field).

### The interpreter (part 1)

It's time for the EVM to actually execute DAI's code. To accomplish this, the EVM has a couple of elements at hand. It has [a stack][205] that can hold [up to 1024 elements][206] (though only the first 16 are directly accessible with the available opcodes). It has a volatile [read/write memory space][207]. It has a [program counter][208]. It has a special read-only memory space called calldata [where the call's input data is kept][209]. Among other stuff.

As usual, there's some necessary setup and validations before jumping into the juicy stuff. First, the [call depth is incremented][210] by one. Second, the [read-only mode is set][211] if necessary. Ours is not a read-only call (see the `false` argument passed [here][212]). Otherwise some EVM operations wouldn't be allowed. These include state-changing EVM instructions [`SSTORE`][213], [`CREATE`][214], [`CREATE2`][215], [`SELFDESTRUCT`][216], [`CALL`][217] with positive value, and [`LOG`][218].

The interpreter now enters [the execution loop][219]. It consists of sequentially [executing][220] the opcodes in DAI's code as [indicated by the program counter][221] and the current EVM instruction set. For the time being we're using the [London instruction set][222] - which was [configured in the jump table][223] when the interpreter was first instantiated.

The loop also takes care of [keeping a healthy stack][224] (avoiding under/overflows). And spending each operation's [fixed gas costs][225], as well as [dynamic gas costs][226] when appropriate. These dynamic costs [include][227], for example, the expansion of EVM memory (read more about memory expansion costs are calculated [here][228]). Note that gas is consumed _before_ execution of an opcode - not after.

The actual behavior of each possible instruction can be found implemented in [this Geth file][229]. By just skimming through it one can begin to see how these instructions work with the stack, the memory, the calldata and the state.

At this point we'd need to jump straight into DAI's opcodes and follow their execution for our transaction. Yet I don't think that's the best way to approach this. I'd rather first walk away from the EVM and Geth, and move into Solidity lands. This should give us a more valuable overview of the high-level behavior of an ERC20 transfer operation.

### Solidity execution

The DAI smart contract was coded in [Solidity][230]. It is an object-oriented, high-level language that when compiled, outputs EVM bytecode able to deploy smart contracts on an EVM-compatible chain (Ethereum in our case).

DAI's source code can be found [verified in block explorers][231], or [in GitHub][232]. For ease of reference, I'll be pointing to the first.

Before we begin, let's always keep in mind that the EVM knows nothing about Solidity. It knows nothing about its variables, functions, the layout of contracts, ABI-encoding, etc. The Ethereum blockchain stores plain hard EVM bytecode, not fancy Solidity code.

You might wonder then how come when you go to any block explorer, they show you Solidity code at Ethereum addresses. Well, it's just a faÃ§ade. In most block explorers people can upload Solidity source code, and the explorer takes care of compiling the source with specific compiler settings. If the compiler's output produced by the explorer matches what's stored at the specified address on the blockchain, then the contract's source code is said to be "verified". From then on, anyone that navigates to that address sees the Solidity code of that address, instead of only the EVM bytecode stored at it.

A non-trivial consequence of the above is that to some extent we're trusting block explorers to show us the legitimate code (which might not necessarily be true, even if [accidentally][233]). There are might be [alternatives][234] to this though - unless every time you want to read a contract you verify source code against your own node.

Anyway, back to DAI's Solidity code now.

On the DAI smart contract (compiled with Solidity [v0.5.12][235]), let's focus on [the function][236] to execute: `transfer`.

`function transfer(address dst, uint wad) external returns (bool) {     return transferFrom(msg.sender, dst, wad); }`

When `transfer` is run, it will [call another function][237] named `transferFrom`, then returning whatever boolean flag the latter returns. The first and second argument of `transfer` (here named `dst` and `wad`) are passed directly to `transferFrom`. This function additionally reads the sender's address (available as a [Solidity global variable][238] in `msg.sender`).

For our case, these would be the values passed to `transferFrom`:

`return transferFrom(     msg.sender, // 0x6fC27A75d76d8563840691DDE7a947d7f3F179ba (my address on the local testing node)     dst,        // 0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045 (Vitalik's address)     wad         // 1000000000000000000 (1 DAI in wei units) );`

Let's see the [`transferFrom` function][239] then.

`function transferFrom(address src, address dst, uint wad) public returns (bool) {    ... }`

First, the sender's [balance is checked][240] against the amount being transferred.

`require(balanceOf[src] >= wad, "Dai/insufficient-balance");`

It's simple: you cannot transfer more DAI than what you have in balance. If I didn't have 1 DAI, execution would halt at this point, returning an error with a message. Note that each address' balance is tracked on the smart contract storage. In a [map-like data structure named `balanceOf`][241]. If you have at least 1 DAI, I can assure you your account's address has a record somewhere in there.

Second, token [allowances are validated][242].

`// don't bother too much about this :) if (src != msg.sender && allowance[src][msg.sender] != uint(-1)) {     require(allowance[src][msg.sender] >= wad, "Dai/insufficient-allowance");     allowance[src][msg.sender] = sub(allowance[src][msg.sender], wad); }`

This does not concern us right now. Because we're not executing the transfer on behalf of another account. Though do note that's a mechanism all ERC20 tokens should implement - DAI not being the exception. In essence, you can approve other accounts to transfer DAI tokens from your account.

Third, the actual [balance swap][243] happens.

`balanceOf[src] = sub(balanceOf[src], wad); balanceOf[dst] = add(balanceOf[dst], wad);`

When sending 1 DAI, the sender's balance is decreased by 1000000000000000000, and the receiver's balance is incremented by 1000000000000000000. These operations are done reading and writing on the `balanceOf` data structure. It's worth noting the use of two special functions `add` and `sub` to do the math.

Why not simply use the `+` and `-` operators ?

Remember: this contract was compiled with Solidity 0.5.12. At that point in time the compiler did not include over/underflow checks as it does today. Thus developers had to remember (or be reminded ğŸ˜›) to implement them by themselves where appropriate. Thus the use of `add` and `sub` in the DAI contract. They are just custom internal functions to perform addition and subtraction with bound checks to avoid arithmetic issues.

`function add(uint x, uint y) internal pure returns (uint z) {     require((z = x + y) >= x); }  function sub(uint x, uint y) internal pure returns (uint z) {     require((z = x - y) <= x); }`

The `add` function sums `x` and `y`, halting execution if the result of the operation is lower than `x` (thus preventing integer overflow).

The `sub` function subtracts `y` from `x`, halting execution if the result of the operation is greater than `x` (thus preventing integer underflow).

Fourth, a `Transfer` event is [emitted][244] (as [suggested by the ERC20 spec][245]).

`emit Transfer(src, dst, wad);`

An event is a logging operation. Data emitted in an event can later be retrieved from off-chain services reading the blockchain, though never by other contracts.

In our transfer operation the emitted event appears to log three elements. The sender's address (`0x6fC27A75d76d8563840691DDE7a947d7f3F179ba`), the receiver's address (`0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045`), and the amount sent (`1000000000000000000`).

The first two correspond to the parameters labeled as `indexed` in the event's declaration. Indexed parameters facilitate data retrieval, allowing filtering for any of the corresponding logged values. Unless the event is labeled as `anonymous`, the event identifier is also included as a topic.

Hence, being more specific, the `Transfer` event we're dealing with actually logs 3 topics (the event's identifier, the sender's address and the receiver's address) and 1 value (the amount of DAI transferred). We'll cover more details about this event once we get to lower-level EVM stuff.

At the end of the function, the boolean value `true` is [returned][246] (as [suggested by the ERC20 spec][247]).

`return true;`

That's a way of signaling that the transfer was successfully executed. This boolean flag is passed up to the outer `transfer` function that initiated the call (which simply returns it as well).

And that's it! If you've ever sent DAI, be certain that's the logic you've executed. That's the job you've paid to be done for you by a global decentralized network of nodes.

Hold on. I may have gone too far. That's kind of a lie. Because as I told you earlier, the EVM knows nothing about Solidity. Nodes execute no Solidity. They execute EVM bytecode.

It's time for the real deal.

### EVM execution

I'm turning quite technical in this section. I'll assume you're somewhat familiar with looking at some EVM bytecode. If you're not, I _highly_ recommend reading [this series][248] or [this newer one][249]. There you will find lots of the concepts in this section explained individually and in more depth.

DAI's raw bytecode is tough to look at - we already witnessed it in a previous section. A prettier way to study it is using a disassembled version. You can find Dai's disassembled bytecode [here][250] (I've extracted it to [this gist][251] for ease of reference).

#### Free memory pointer and call's value

The first three instructions shouldn't come as a surprise if you're already familiar with the Solidity compiler. It's simply initializing the free memory pointer.

`0x0: PUSH1     0x80 0x2: PUSH1     0x40 0x4: MSTORE`    

The Solidity compiler reserves memory slots from `0x00` to `0x80` for internal stuff. So the "free memory pointer" is a pointer to the first slot of EVM memory that can be freely used. It is stored at `0x40`, and at initialization points to `0x80`.

Keep in mind that all EVM opcodes have a counterpart implementation in Geth. For example, you can [really see][252] how the implementation of `MSTORE` pops two stack elements and writes to the EVM memory a word of 32 bytes:

`func opMstore(pc *uint64, interpreter *EVMInterpreter, scope *ScopeContext) ([]byte, error) {     // pop value of the stack     mStart, val := scope.Stack.pop(), scope.Stack.pop()     scope.Memory.Set32(mStart.Uint64(), &val)     return nil, nil }`

The next EVM instructions in DAI's bytecode ensure that the call doesn't hold any value. If it had, execution would halt at the `REVERT` instruction. Note the use of the `CALLVALUE` instruction (implemented [here][253]) to read the current call's value.

`0x5: CALLVALUE  0x6: DUP1       0x7: ISZERO     0x8: PUSH2     0x10 0xb: JUMPI      0xc: PUSH1     0x0 0xe: DUP1       0xf: REVERT`

Our call doesn't hold any value (the `value` field of the transaction was set to zero) - so we're good to continue.

#### Validating calldata (part 1)

Next: another check introduced by the compiler. This time it's figuring out whether the calldata's size (obtained with the `CALLDATASIZE` instruction - implemented [here][254]) is lower than 4 bytes (see the `0x4` and the `LT` instruction below ?). In such case it would jump to position `0x142`. Halting execution at the `REVERT` instruction in position `0x146`.

`0x10: JUMPDEST 0x11: POP        0x12: PUSH1     0x4 0x14: CALLDATASIZE 0x15: LT         0x16: PUSH2     0x142 0x19: JUMPI  ...  0x142: JUMPDEST   0x143: PUSH1     0x0 0x145: DUP1       0x146: REVERT` 

That means that in the DAI smart contract calldata's size is enforced to be _at least_ 4 bytes. That's because the ABI-encoding mechanism used by Solidity identifies functions with the first four bytes of the keccak256 hash of their signature (usually called "function selector" - [see the spec][255]).

If calldata didn't have at least 4 bytes, it wouldn't be possible to identify the function. So the compiler introduces the necessary EVM instructions to fail early in that scenario. That's what you witnessed above.

In order to call the `transfer(address,uint256)` function, the first four bytes of the calldata must match the function's selector. These are:

`$ cast sig "transfer(address,uint256)" 0xa9059cbb`

That's right. Exactly the same first 4 bytes of the `data` field of the transaction we built earlier:

`0xa9059cbb000000000000000000000000d8da6bf26964af9d7eed9e03e53415d37aa960450000000000000000000000000000000000000000000000000de0b6b3a7640000`

Now that the length of the calldata has been validated, it's time to use it. See below how the first four bytes calldata are placed at the top of the stack (main EVM instruction to notice here is `CALLDATALOAD`, implemented [here][256]).

`0x1a: PUSH1     0x0 0x1c: CALLDATALOAD 0x1d: PUSH1     0xe0 0x1f: SHR`       

In reality `CALLDATALOAD` pushes [32 bytes of calldata][257] to the stack. It needs to be chopped with [the `SHR` instruction][258] to keep the first 4 bytes.

#### Function dispatcher

Don't try to understand the following line by line. Instead, pay attention to the high-level pattern that stands out. I'll add some dividing lines to make it clearer:

`0x20: DUP1 0x21: PUSH4     0x7ecebe00 0x26: GT         0x27: PUSH2     0xb8 0x2a: JUMPI`

`0x2b: DUP1       0x2c: PUSH4     0xa9059cbb 0x31: GT         0x32: PUSH2     0x7c 0x35: JUMPI`

`0x36: DUP1       0x37: PUSH4     0xa9059cbb 0x3c: EQ         0x3d: PUSH2     0x6b4 0x40: JUMPI`

`0x41: DUP1       0x42: PUSH4     0xb753a98c 0x47: EQ         0x48: PUSH2     0x71a 0x4b: JUMPI`

It's no coincidence that some of the hex values being pushed to the stack are 4 bytes long. Those are, indeed, function selectors.

The set of instructions above is a common structure of the bytecode that the Solidity compiler produces. It's usually referred to as "function dispatcher". It resembles an if-else or switch flow. It's simply trying to match the first four bytes of the calldata against the set of known selectors of the contract's functions. Once it finds a coincidence, execution will jump to another section of the bytecode. Where the instructions for that particular function are placed.

Following the above logic, the EVM matches the first four bytes of calldata against the selector of the ERC20 `transfer` function: `0xa9059cbb`. And jumps to bytecode position `0x6b4`. That's how the EVM is told to start executing the transfer of DAI.

#### Validating calldata (part 2)

Having matched the selector and jumped, now the EVM is about to start running specific code related to the function. But before jumping into its details, it needs to somehow remember where to continue executing once all function-related logic has been executed.

The way to do that is simply keeping the appropriate bytecode position in the stack. See the `0x700` value being pushed below. It will linger in stack until at some point (later down the road) it will be retrieved and be used to jump back to wrap up execution.

`0x6b4: JUMPDEST   0x6b5: PUSH2     0x700`

Now let's get more specific to the `transfer` function.

The compiler embeds some logic to ensure the calldata's size is correct for a function with two parameters of `address` and `uint256` type. For the `transfer` function, that is at least 68 bytes (4 bytes for the selector + 64 bytes for the two ABI-encoded parameters).

`0x6b8: PUSH1     0x4 0x6ba: DUP1       0x6bb: CALLDATASIZE 0x6bc: SUB        0x6bd: PUSH1     0x40 0x6bf: DUP2       0x6c0: LT         0x6c1: ISZERO     0x6c2: PUSH2     0x6ca 0x6c5: JUMPI      0x6c6: PUSH1     0x0 0x6c8: DUP1       0x6c9: REVERT`

If the calldata's size was lower, execution would halt at the `REVERT` in position `0x6c9`. Since our transaction's calldata has been correctly ABI-encoded and therefore has the appropriate length, execution jumps to position `0x6ca`.

#### Reading parameters

Next step is for the EVM to read the two parameters provided in the calldata. Those would be the 20-bytes-long address `0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045` and the number `1000000000000000000` (`0x0de0b6b3a7640000` in hex). Both were ABI-encoded in chunks of 32 bytes. Thus there needs to be some basic manipulation to read the right values and place them at the top of the stack.

`0x6ca: JUMPDEST   0x6cb: DUP2       0x6cc: ADD        0x6cd: SWAP1      0x6ce: DUP1       0x6cf: DUP1       0x6d0: CALLDATALOAD 0x6d1: PUSH20    0xffffffffffffffffffffffffffffffffffffffff 0x6e6: AND        0x6e7: SWAP1      0x6e8: PUSH1     0x20 0x6ea: ADD        0x6eb: SWAP1      0x6ec: SWAP3      0x6ed: SWAP2      0x6ee: SWAP1      0x6ef: DUP1       0x6f0: CALLDATALOAD 0x6f1: SWAP1      0x6f2: PUSH1     0x20 0x6f4: ADD        0x6f5: SWAP1      0x6f6: SWAP3      0x6f7: SWAP2      0x6f8: SWAP1      0x6f9: POP        0x6fa: POP        0x6fb: POP        0x6fc: PUSH2     0x1df4 0x6ff: JUMP`

Just to make it more visual, after sequentially applying the above set of instructions (up to `0x6fb`), the top of stack looks like this:

`0x0000000000000000000000000000000000000000000000000de0b6b3a7640000 0x000000000000000000000000d8da6bf26964af9d7eed9e03e53415d37aa96045`

And that's how the EVM swiftly extracts both arguments from calldata, placing them on the stack for future use.

The final two instructions above (bytecode positions `0x6fc` and `0x6ff`) simply make execution jump to position `0x1df4`. Let's continue there.

#### The `transfer` function

During the brief Solidity analysis, we saw that the `transfer(address,uint256)` function was a thin wrapper that called the more complex `transferFrom(address,address,uint256)` function. The compiler translates such internal call to [these EVM instructions][259]:

`0x1df4: JUMPDEST   0x1df5: PUSH1     0x0 0x1df7: PUSH2     0x1e01 0x1dfa: CALLER     0x1dfb: DUP5       0x1dfc: DUP5       0x1dfd: PUSH2     0xa25 0x1e00: JUMP`

First notice the instruction pushing the value `0x1e01`. That's how the EVM is instructed to "remember" the exact position where it should jump back to continue execution after the upcoming internal call.

Then, pay attention to the use of `CALLER` (because in Solidity the internal call uses `msg.sender`). As well as to the two `DUP5` instructions. Together, these are putting at the top of the stack the three necessary arguments for `transferFrom`: the caller's address, the receiver's address, and the amount to be transferred. The last two were already somewhere in the stack, thus the use of `DUP5`. The top of the stack now holds all necessary arguments:

`0x0000000000000000000000000000000000000000000000000de0b6b3a7640000 0x000000000000000000000000d8da6bf26964af9d7eed9e03e53415d37aa96045 0x0000000000000000000000006fc27a75d76d8563840691dde7a947d7f3f179ba`

Finally, following instructions `0x1dfd` and `0x1e00`, execution jumps to position `0xa25`. Where the EVM will start executing the instructions corresponding to the `transferFrom` function.

#### The `transferFrom` function

First thing that needs to be checked is whether the sender has enough DAI in balance - otherwise reverting. The sender's balance is kept in the contract storage. The fundamental EVM instruction needed is then `SLOAD`. However, `SLOAD` needs to know what storage _slot_ needs to be read. For mappings (the type of Solidity data structure that is holding account balances in the DAI smart contract), that's not so straightforward to tell.

I won't dive here into the internal layout of Solidity state variables in contract storage. You may read about it [here for v0.5.15][260]. Suffice to say that given the key address `k` for the mapping `balanceOf`, its corresponding `uint256` value will be kept at storage slot `keccak256(k . p)`, where `p` is the slot position of the mapping itself and `.` is concatenation. You can do the math yourself.

For simplicity, let's just highlight a couple of operations that need to happen. The EVM must i) calculate the storage slot for the mapping, ii) read the value, iii) compare it against the amount to be transferred (a value already in stack). Therefore we should see instructions like `SHA3` for the hashing, `SLOAD` for reading storage, and `LT` for the comparison.

`0xa25: JUMPDEST   0xa26: PUSH1     0x0 0xa28: DUP2       0xa29: PUSH1     0x2 0xa2b: PUSH1     0x0 0xa2d: DUP7       0xa2e: PUSH20    0xffffffffffffffffffffffffffffffffffffffff 0xa43: AND        0xa44: PUSH20    0xffffffffffffffffffffffffffffffffffffffff 0xa59: AND        0xa5a: DUP2       0xa5b: MSTORE     0xa5c: PUSH1     0x20 0xa5e: ADD        0xa5f: SWAP1      0xa60: DUP2       0xa61: MSTORE     0xa62: PUSH1     0x20 0xa64: ADD        0xa65: PUSH1     0x0 0xa67: SHA3      --> calculating storage slot 0xa68: SLOAD     --> reading storage 0xa69: LT        --> comparing balance against amount 0xa6a: ISZERO     0xa6b: PUSH2     0xadc 0xa6e: JUMPI`    

If the sender didn't have enough DAI, execution would [follow at `0xa6f` and finally hit the `REVERT` at `0xadb`][261]. Since I did not forget to load 1 DAI in my sender account's balance, let's then proceed to position `0xadc`.

The following set of instructions correspond to the EVM validating whether the caller matches the sender's address (remember the `if (src != msg.sender ...) { ... }` code segment in the contract).

`0xadc: JUMPDEST   0xadd: CALLER     0xade: PUSH20    0xffffffffffffffffffffffffffffffffffffffff 0xaf3: AND        0xaf4: DUP5       0xaf5: PUSH20    0xffffffffffffffffffffffffffffffffffffffff 0xb0a: AND        0xb0b: EQ         0xb0c: ISZERO     0xb0d: DUP1       0xb0e: ISZERO     0xb0f: PUSH2     0xbb4 0xb12: JUMPI ... 0xbb4: JUMPDEST   0xbb5: ISZERO     0xbb6: PUSH2     0xdb2 0xbb9: JUMPI`

Since they don't match, continue executing at position `0xdb2`.

Doesn't this code below remind you of something ? Check out the instructions being used. Again, don't focus on them individually. Use your intuition to spot high-level patterns and the most relevant instructions.

`0xdb2: JUMPDEST   0xdb3: PUSH2     0xdfb 0xdb6: PUSH1     0x2 0xdb8: PUSH1     0x0 0xdba: DUP7       0xdbb: PUSH20    0xffffffffffffffffffffffffffffffffffffffff 0xdd0: AND        0xdd1: PUSH20    0xffffffffffffffffffffffffffffffffffffffff 0xde6: AND        0xde7: DUP2       0xde8: MSTORE     0xde9: PUSH1     0x20 0xdeb: ADD        0xdec: SWAP1      0xded: DUP2       0xdee: MSTORE     0xdef: PUSH1     0x20 0xdf1: ADD        0xdf2: PUSH1     0x0 0xdf4: SHA3       0xdf5: SLOAD      0xdf6: DUP4       0xdf7: PUSH2     0x1e77 0xdfa: JUMP`

If it resembles reading a mapping from storage, it's because it is! The above is the EVM reading the sender's balance from the `balanceOf` mapping.

Execution then jumps to position `0x1e77`, where the body of the `sub` function is placed.

The `sub` function subtracts two numbers, reverting upon integer underflow. I'm not including the bytecode, though you can follow it [here][262]. The result of the arithmetic operation is kept on the stack.

Back to the instructions corresponding to `transferFrom` function's body, now the result of the subtraction is to be written to storage - updating the `balanceOf` mapping. Try to notice below the calculation performed to obtain the appropriate storage slot of the mapping entry, which leads to the execution of the `SSTORE` instruction. This instruction is the one that effectively writes data to state - that is, that updates the contract's storage.

`0xdfb: JUMPDEST   0xdfc: PUSH1     0x2 0xdfe: PUSH1     0x0 0xe00: DUP7       0xe01: PUSH20    0xffffffffffffffffffffffffffffffffffffffff 0xe16: AND        0xe17: PUSH20    0xffffffffffffffffffffffffffffffffffffffff 0xe2c: AND        0xe2d: DUP2       0xe2e: MSTORE     0xe2f: PUSH1     0x20 0xe31: ADD        0xe32: SWAP1      0xe33: DUP2       0xe34: MSTORE     0xe35: PUSH1     0x20 0xe37: ADD        0xe38: PUSH1     0x0 0xe3a: SHA3       0xe3b: DUP2       0xe3c: SWAP1      0xe3d: SSTORE` 

A pretty similar set of opcodes is run to update the receiver's account balance. First [is read from the `balanceOf` mapping in storage][263]. Then the balance is added to the amount being transferred [using the `add` function][264]. At last the result is [written to the appropriate storage slot][265].

#### Logging

In the contract's code the `Transfer` event was emitted after updating balances. So there has to be a set of instructions in the bytecode under analysis that take care of emitting such event with the appropriate data.

However, events are yet another thing that belong to Solidity's fantasy world. In EVM world, events correspond to logging operations.

Logging is performed with the available set of `LOG` instructions. There are a couple of variants, depending on how many topics are to be logged. In DAI's case, we already noted that the emitted `Transfer` event has 3 topics.

Then it's no surprise to find a set of instructions that lead to running the `LOG3` instruction.

`0xeca: POP        0xecb: DUP3       0xecc: PUSH20    0xffffffffffffffffffffffffffffffffffffffff 0xee1: AND  0xee2: DUP5 0xee3: PUSH20    0xffffffffffffffffffffffffffffffffffffffff 0xef8: AND        0xef9: PUSH32    0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef 0xf1a: DUP5       0xf1b: PUSH1     0x40 0xf1d: MLOAD      0xf1e: DUP1       0xf1f: DUP3       0xf20: DUP2       0xf21: MSTORE     0xf22: PUSH1     0x20 0xf24: ADD        0xf25: SWAP2      0xf26: POP        0xf27: POP        0xf28: PUSH1     0x40 0xf2a: MLOAD      0xf2b: DUP1       0xf2c: SWAP2      0xf2d: SUB        0xf2e: SWAP1      0xf2f: LOG3`      

There's at least one value that stands out in those instructions: `0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef`. That's the event's main identifier. Also called topic 0. It is a static value calculated by the compiler at compiling time (embedded in the contract's runtime bytecode). As noted previously, no more than the hash of the event's signature:

`$ cast keccak "Transfer(address,address,uint256)" 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef`

Right before reaching the `LOG3` instruction, the stack looks like this:

`0x0000000000000000000000000000000000000000000000000000000000000080 0x0000000000000000000000000000000000000000000000000000000000000020 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef -- topic 0 (event identifier) 0x0000000000000000000000006fc27a75d76d8563840691dde7a947d7f3F179ba -- topic 1 (sender's address) 0x000000000000000000000000d8da6bf26964af9d7eed9e03e53415d37aa96045 -- topic 2 (receiver's address)`

Where's the amount of the transfer then ? In memory! Before reaching `LOG3`, the EVM was first instructed to store the amount in memory. So that it can later be consumed by the logging instruction. If you look at position `0xf21`, you'll see the `MSTORE` instruction in charge of doing so.

So once `LOG3` is reached, it is safe for the EVM to grab the actual value logged from memory, starting at offset `0x80` and reading `0x20` bytes (first two stack elements above).

Another way of understanding logging is looking at its [implementation in Geth][266]. In there you'll find a single function in charge of handling all logging instructions. You can see how i) an empty array of topics [is initialized][267], ii) the memory offset and data size are [read from the stack][268], iii) the topics are [read from stack][269] and [inserted in the array][270], iv) the value is [read from memory][271], v) the log, containing address where it was emitted, topics and value, [is appended][272].

How those logs are later recovered, we'll find out soon enough.

#### Returning

Last thing for the `transferFrom` function is to return the boolean value `true`. That's why the first instruction after `LOG3` is simply pushing the `0x1` value to the stack.

`0xf30: PUSH1    0x1`

The next instructions prepare the stack to exit the `transferFrom` function, going back to its wrapper `transfer` function. Remember that the position for this next jump had been already stored in the stack - that's why you don't see it in the opcodes below.

`0xf32: SWAP1      0xf33: POP        0xf34: SWAP4      0xf35: SWAP3      0xf36: POP        0xf37: POP        0xf38: POP        0xf39: JUMP`

Back in the `transfer` function, all there's to do is to prepare the stack for the final jump. To a position where execution will be wrapped up. The position for this upcoming jump had also been stored in the stack previously (remember the `0x700` value being pushed?).

`0x1e01: JUMPDEST   0x1e02: SWAP1      0x1e03: POP        0x1e04: SWAP3      0x1e05: SWAP2      0x1e06: POP        0x1e07: POP        0x1e08: JUMP` 

All that's left is to prepare the stack for the final instruction: `RETURN`. This instruction is in charge of reading some data from memory, and passing it back to the original caller.

For the DAI transfer, the returned data would simply include the `true` boolean flag returned by the `transfer` function. Remember that the value had been already placed at the stack.

The EVM begins with grabbing the first available position of free memory. This is done by reading the free memory pointer:

`0x700: JUMPDEST   0x701: PUSH1     0x40 0x703: MLOAD`

Next, the value must be stored in memory with `MSTORE`. Although not so straightforward to tell, the instructions below are just the ones the compiler found most appropriate to prepare the stack for the `MSTORE` operation.

`0x704: DUP1       0x705: DUP3       0x706: ISZERO     0x707: ISZERO     0x708: ISZERO     0x709: ISZERO     0x70a: DUP2       0x70b: MSTORE`

The `RETURN` instruction copies the returned data from memory. So it needs to be told how much memory to read, and where to start. The instructions below simply tell the EVM to read and return `0x20` bytes from memory starting at the free memory pointer.

`0x70c: PUSH1     0x20 0x70e: ADD        0x70f: SWAP2      0x710: POP        0x711: POP        0x712: PUSH1     0x40 0x714: MLOAD      0x715: DUP1       0x716: SWAP2      0x717: SUB        0x718: SWAP1      0x719: RETURN` 

The value `0x0000000000000000000000000000000000000000000000000000000000000001` (corresponding to the boolean `true`) is returned.

Execution halts.

### The interpreter (part 2)

Bytecode execution has finished. The interpreter must stop [iterating][273]. In Geth, that's done like this:

`// interpreter's execution loop for {      ...     // execute the operation     res, err = operation.execute(&pc, in, callContext)     if err != nil {         break     }     ... }`

That means that the implementation of the `RETURN` opcode should somehow return an error. Even for successful executions such as ours. Indeed, [it does][274]. Though it acts as a flag - the error is actually [deleted][275] when it matches the flag returned by the successful execution of the `RETURN` opcode.

### Gas refunds and payments

With the interpreter run finished, we're [back in the call][276] that originally triggered it. The run [was completed successfully][277]. Thus the returned data and any gas remaining is simply [returned][278].

The call's finished as well. Execution follows wrapping up the state transition.

First [providing gas refunds][279]. These are added to any gas leftovers in the transaction. The refunded amount is capped to 1/5 of the gas used (due to [EIP 3529][280]). All gas available now (remaining plus refunded) is [paid back in ETH][281] to the sender's account, at the rate originally set by the sender in the transaction. All gas left is [re-added][282] to the available gas in the block - so that subsequent transactions can consume it.

Then [paying the coinbase address][283] (the miner's address in PoW, the validator's address in PoS) what was originally promised: the tip. Interestingly, payment is done for all gas used during execution. Even if some of it was later refunded. Moreover, note [here][284] how the _effective_ tip is calculated. Not only noticing that it is capped by the `maxPriorityFeePerGas` transaction field. But more importantly, realizing that it _does not_ include the base fee! That's no mistake - Ethereum enjoys [watching the ETH burn][285].

At last [the execution result is wrapped in a prettier structure][286]. Including the used gas, any EVM error that could have aborted execution (none in our case), along with the returned data from the EVM.

### Building the transaction receipt

The structure representing the execution result is now passed [back][287] [up][288]. At this point Geth does [some internal cleanup][289] of the execution state. Once done, it [accumulates the gas used][290] in the transaction (including refunds).

Most importantly, now is the time the transaction receipt is created. The receipt's an object summarizing data related to the transaction's execution. It includes information such as [execution status][291] (success/failure), the [transaction's hash][292], [gas units used][293], [address of created contract][294] (none in our case), [logs emitted][295], the [transaction's bloom filter][296], and [more][297].

We'll retrieve the full contents of our transaction's receipt soon.

If you'd like to dig deeper into the transaction's logs and the role of the bloom filter, check out [noxx's article][298].

## Sealing the block

Execution of subsequent transactions continue happening until the block runs out of space.

That's when the node invokes the consensus engine to [finalize][299] the block. In PoW that entails [accumulating mining rewards][300] (issuing [full rewards][301] in ETH to the coinbase address, along with [partial rewards][302] for [ommer blocks][303]) and [updating the final state root][304] of the block accordingly.

Next, the actual block [is assembled][305], putting [all data in its right place][306]. Including information such as the header's [transaction hash][307], or the [receipts hash][308].

All ready for the real PoW mining now. [A new "task"][309] is created and [pushed to the right listener][310]. The [sealing task][311], delegated to the consensus engine, starts.

I won't explain in detail how the actual mining is done for PoW. Lots about it on the Internet already. Just note that in Geth this involves a [multithreaded try-and-error process][312] to [find a number][313] that [satisfies a necessary condition][314]. Needless to say, once Ethereum switches to Proof of Stake the sealing process will be handled quite differently.

The mined block is [pushed to the appropriate channel][315] and [received at the results loop][316]. Where [receipts and logs are updated accordingly][317] with the latest block data after its been effectively mined.

The block is finally [written to the chain][318], placing it at its head.

## Broadcasting the block

Next step is to [announce to the whole network][319] that a new block has been mined. Meanwhile the block is internally [stored into the set of pending ones][320]. Patiently awaiting for confirmations from other nodes.

The announcement is done [posting a specific event][321], picked up by the [mined broadcast loop][322]. In there the block is fully [propagated to a subset of peers][323] and [made available][324] to the rest in a lighter fashion.

More specifically, propagation entails [sending block data to the square root of connected peers][325]. Internally this is implemented [pushing the data to the queued blocks channel][326], until its [sent][327] via the [p2p layer][328]. The p2p message is identified as `NewBlockMsg`. The rest receives a [lightweight announcement including the block hash][329].

Note that this is only valid for PoW. [Block propagation will happen on consensus engines][330] in Proof of Stake.

## Verifying the block

Peers are continuously [listening for messages][331]. Each type of [possible message has an associated handler][332] that is [invoked][333] as soon as the corresponding message is received.

Consequently, upon getting the `NewBlockMsg` message with the block's data, [its corresponding handler][334] is executed. The handler [decodes the message][335] and runs some [early validations][336] on the propagated block. These include preliminary [sanity checks][337] on the header's data, mostly ensuring they are filled and bounded. As well as validations for the block's [uncle][338] and [transaction][339] hashes.

Then [the peer that sent the message is marked][340] as owning the block. Thus avoiding to later propagate the block back to it.

At last, the packet is [passed down][341] to [a second handler][342], where the block is going to be [enqueued for import][343] into the local copy of the chain. The enqueuing is done by [sending a direct import request to the corresponding channel][344]. When the request is [picked up][345], it triggers the [actual enqueuing operation][346]. Finally [pushing][347] the block data to the queue.

The block is now in the local queue ready to be processed. This queue is [read from periodically][348] in the node's block fetcher main loop. When the block makes it to the front, the node will pick it up and [attempt to import it][349].

There are a at least two validations worth highlighting prior to the actual insertion of the candidate block.

First, the local chain must already [include the parent of the propagated block][350].

Second, the block's header [must be valid][351]. These validations are _the real ones_. Meaning, the ones that actually matter for consensus, and are specified in Ethereum's [yellow paper][352]. Hence, they are [handled by the consensus engine][353].

Just as examples, the engine checks that the [block's proof of work is valid][354], or that the block's timestamp is [not in the past][355] nor [not too far ahead into the future][356], or that the block's number [has been increased correctly][357]. Among others.

Having verified that its header follows consensus rules, the whole block is further [propagated to a subset of peers][358]. Only then [the actual import is run][359].

There's _a lot_ happening during an import. So I'll cut right to the chase.

After [several additional validations][360], the [parent's block state is retrieved][361]. This is the state on top of which the first transaction of the new block is going to be executed. Using it as a reference point, [the entire block is processed][362]. If you've ever heard that all Ethereum nodes are expected to execute and validate every single transaction, now you can be certain of it. Afterwards, the [post-state is validated][363] (see how [here][364]). Finally, [the block is written][365] to the local chain.

The successful import leads to [announcing][366] (not fully broadcasting) the block to the rest of the node's peers.

The whole verification process is replicated across all nodes that receive the block. A good portion will accept it into their local chains, and later newer blocks will arrive to insert on top of it.

## Retrieving the transaction

After a few blocks have been mined on top of the one where the transaction was included, one can start to safely assume that the transaction has been indeed confirmed.

Retrieving the transaction from the chain is quite simple. All we need is its hash. Conveniently, it was obtained as soon as we first submitted the transaction.

The data of the transaction itself, plus the block's hash and number, can always be retrieved at the node's `eth_getTransactionByHash` endpoint. Unsurprisingly, it now returns:

`{     "hash": "0xbf77c4a9590389b0189494aeb2b2d68dc5926a5e20430fb5bc3c610b59db3fb5",     "type": 2,     "accessList": [],     "blockHash": "0xe880ba015faa9aeead0c41e26c6a62ba4363822ddebde6dd77a759a753ad2db2",     "blockNumber": 15166167,     "transactionIndex": 0,     "confirmations": 6,     "from": "0x6fC27A75d76d8563840691DDE7a947d7f3F179ba",     "maxPriorityFeePerGas": 2000000000,     "maxFeePerGas": 120000000000,     "gasLimit": 40000,     "to": "0x6B175474E89094C44Da98b954EedeAC495271d0F",     "value": 0,     "nonce": 0,     "data": "0xa9059cbb000000000000000000000000d8da6bf26964af9d7eed9e03e53415d37aa960450000000000000000000000000000000000000000000000000de0b6b3a7640000",     "r": "0x057d733933b12238a2aeb0069b67c6bc58ca8eb6827547274b3bcf4efdad620a",     "s": "0x00e49937ec81db89ce70ebec5e51b839c0949234d8aad8f8b55a877bd78cc293",     "v": 1,     "creates": null,     "chainId": 31337 }`

The transaction's receipt can be requested at the `eth_getTransactionReceipt` endpoint. Depending on the node you're running this query, it might be the case you also get additional information on top of the expected transaction receipt data. This is the transaction receipt I got from my local fork of mainnet:

`{     "to": "0x6B175474E89094C44Da98b954EedeAC495271d0F",     "from": "0x6fC27A75d76d8563840691DDE7a947d7f3F179ba",     "contractAddress": null,     "transactionIndex": 0,     "gasUsed": 34706,     "logsBloom": "0x00000000000000000800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000008000000000000000000000000000000000000000011000000000000000000000000000000000000000000000000000010000000000000004000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000002000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000",     "blockHash": "0x8b6d44d6cf39d01181b90677f8a77a2605d6e70c40d649eda659499063a19c77",     "transactionHash": "0xbf77c4a9590389b0189494aeb2b2d68dc5926a5e20430fb5bc3c610b59db3fb5",     "logs": [         {             "transactionIndex": 0,             "blockNumber": 15166167,             "transactionHash": "0xbf77c4a9590389b0189494aeb2b2d68dc5926a5e20430fb5bc3c610b59db3fb5",             "address": "0x6B175474E89094C44Da98b954EedeAC495271d0F",             "topics": [                 "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",                 "0x0000000000000000000000006fc27a75d76d8563840691dde7a947d7f3f179ba",                 "0x000000000000000000000000d8da6bf26964af9d7eed9e03e53415d37aa96045"             ],             "data": "0x0000000000000000000000000000000000000000000000000de0b6b3a7640000",             "logIndex": 0,             "blockHash": "0x8b6d44d6cf39d01181b90677f8a77a2605d6e70c40d649eda659499063a19c77"         }     ],     "blockNumber": 15166167,     "confirmations": 6, // number of blocks I waited before fetching the receipt     "cumulativeGasUsed": 34706,     "effectiveGasPrice": 9661560402,     "type": 2,     "byzantium": true,     "status": 1 }`

You saw that ? It says `"status": 1`.

That can only mean one thing: success!

## Afterword

There's definitely _far more_ to this story.

In some sense it's never-ending. There's always one more caveat. One more side note. An alternative execution path. Another node implementation. Another EVM instruction I might have skipped. Another wallet that handles things differently. All things that would take us one step closer to finding out "the real truth" behind what happens when you send 1 DAI.

Luckily, that's not what I intended to do. I hope the last +10k words did not make you think that ğŸ˜›. Allow me to shed some light here.

In hindsight, this article is the byproduct of mixing curiosity and frustration.

Curiosity because I've been doing Ethereum smart contract security for more than 4 years, yet I hadn't took as much as time as I would've liked to manually explore, in depth, the complexities of the base layer. I really wanted to gain first-hand experience looking at the actual implementation of Ethereum itself. But smart contracts always got in the middle. Now that I've finally managed to found more peaceful times, it seemed the right time to go back to roots and embark on this adventure.

Curiosity wasn't enough though. I needed an excuse. A trigger. I knew what I had in mind was gonna be tough. So I needed a strong enough reason not only to get started. But also, more importantly, to get re-started whenever I would feel I was tired of trying to make sense out of Ethereum's code.

I found it where I wasn't looking. I found it in frustration.

Frustration at the absolutely mind-blowing lack of transparency we've grown so used to when sending money. If you've ever needed to do it in a developing country under increasingly strict capital controls, no doubt you feel me. So I wanted to remind myself that we can do better. I decided to channel my frustration in writing.

This article's also served me as a reminder. That if you can escape the fuzz, the price, the monkeys in JPEGs, the ponzis, the rugpulls, the thefts, there's still value in here. This is no "magic" internet money. There's real math, cryptography and computer science going. Being open source, you can see every single piece moving. You can almost touch them. No matter the day nor the time. No matter who you are. No matter where you come from.

So, I'm sorry for the clickbait-y title. This was never about what happens when you send 1 DAI.

It was about having the possibility to understand it.

[1]: https://notonlyowner.com/learn/que-pasa-cuando-envias-un-dai
[2]: https://makerdao.world/en/learn/Dai/
[3]: https://metamask.io
[4]: #building-the-transaction
[5]: #the-transactions-data-field
[6]: #gas-wizardry
[7]: #access-list-and-transaction-type
[8]: #signing-the-transaction
[9]: #serialization
[10]: #submitting-the-transaction
[11]: #reception
[12]: #inspecting-the-mempool
[13]: #propagation
[14]: #work-preparation-and-transaction-inclusion
[15]: #execution
[16]: #preparation-part-1
[17]: #preparation-part-2
[18]: #the-call
[19]: #the-interpreter-part-1
[20]: #solidity-execution
[21]: #evm-execution
[22]: #free-memory-pointer-and-calls-value
[23]: #validating-calldata-part-1
[24]: #function-dispatcher
[25]: #validating-calldata-part-2
[26]: #reading-parameters
[27]: #the-transfer-function
[28]: #the-transferFrom-function
[29]: #logging
[30]: #returning
[31]: #the-interpreter-part-2
[32]: #gas-refunds-and-payments
[33]: #building-the-transaction-receipt
[34]: #sealing-the-block
[35]: #broadcasting-the-block
[36]: #verifying-the-block
[37]: #retrieving-the-transaction
[38]: #afterword
[39]: https://github.com/ethereumbook/ethereumbook/blob/develop/05wallets.asciidoc
[40]: https://chainlist.org/
[41]: https://www.jsonrpc.org/
[42]: https://eips.ethereum.org/EIPS/eip-20
[43]: https://library.dedaub.com/contracts/Ethereum/6b175474e89094c44da98b954eedeac495271d0f/source
[44]: https://library.dedaub.com/contracts/Ethereum/6b175474e89094c44da98b954eedeac495271d0f/source?line=122
[45]: https://docs.soliditylang.org/en/latest/abi-spec.html
[46]: https://soliditylang.org/
[47]: https://book.getfoundry.sh/reference/cast/cast-calldata.html
[48]: https://ethereum.org/en/developers/docs/gas/#what-is-gas
[49]: https://docs.infura.io/infura/networks/ethereum/json-rpc-methods/eth_feehistory
[50]: https://composer.alchemyapi.io?share=eJwdyEEKgCAQBdC7.LULCyTwBK1atomIoSaKUkMnIqK7J_0e78G40OphtYJnuULcfjuWJUwNOYZF9jAz12uSEG8oHBTJtbSfnGA7FDrfTsJJMrrSKKNVZXr07wcDJR59
[51]: https://github.com/ethereum/execution-apis/blob/main/src/eth/fee_market.json#L14-L94
[52]: https://www.blocknative.com/blog/eip-1559-fees
[53]: https://eips.ethereum.org/EIPS/eip-2930
[54]: https://eips.ethereum.org/EIPS/eip-2718
[55]: https://eips.ethereum.org/EIPS/eip-1559#abstract
[56]: https://en.wikipedia.org/wiki/ECDSA
[57]: https://ethereum.org/en/developers/docs/data-structures-and-encoding/rlp/
[58]: https://github.com/ethereumjs/ethereumjs-monorepo/tree/master/packages/tx
[59]: https://docs.ethers.io/v5/single-page/
[60]: https://ethereum.org/en/developers/docs/data-structures-and-encoding/rlp/
[61]: https://www.youtube.com/watch?v=uZ7vkmUNTPA
[62]: https://github.com/ethereum/go-ethereum/tree/v1.10.18
[63]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/internal/ethapi/api.go#L1698-L1706
[64]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/internal/ethapi/api.go#L1702
[65]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/internal/ethapi/api.go#L1623-L1625
[66]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/eth/ethconfig/config.go#L95
[67]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/internal/ethapi/api.go#L1626-L1629
[68]: https://eips.ethereum.org/EIPS/eip-155
[69]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/internal/ethapi/api.go#L1630
[70]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/eth/api_backend.go#L245-L247
[71]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/tx_pool.go#L852-L857
[72]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/tx_pool.go#L843-L850
[73]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/tx_pool.go#L226-L271
[74]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/tx_pool.go#L896-L901
[75]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/tx_pool.go#L902-L910
[76]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/tx_pool.go#L648-L753
[77]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/tx_pool.go#L586-L646
[78]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/tx_pool.go#L604-L607
[79]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/tx_pool.go#L595-L598
[80]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/tx_pool.go#L49-L53
[81]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/tx_pool.go#L628-L631
[82]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/tx_pool.go#L632-L636
[83]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/internal/ethapi/api.go#L1633-L1645
[84]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/internal/ethapi/api.go#L1646
[85]: https://www.paradigm.xyz/2020/08/ethereum-is-a-dark-forest
[86]: https://arxiv.org/pdf/1904.05234.pdf
[87]: https://github.com/flashbots/mev-geth
[88]: https://docs.flashbots.net/flashbots-protect/rpc/quick-start
[89]: https://ethereum.org/en/developers/docs/consensus-mechanisms/pow/
[90]: https://ethereum.org/en/developers/docs/consensus-mechanisms/pos/
[91]: https://github.com/ethereum/builder-specs
[92]: https://github.com/ethereum/devp2p/
[93]: https://github.com/ethereum/devp2p/blob/master/caps/eth.md#transaction-exchange
[94]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/eth/handler.go#L524-L528
[95]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/node/defaults.go#L64
[96]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/eth/handler.go#L603-L607
[97]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/eth/handler.go#L621-L622
[98]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/eth/protocols/eth/peer.go#L183-L198
[99]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/eth/protocols/eth/peer.go#L213-L223
[100]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/tx_pool.go#L390-L396
[101]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/tx_pool.go#L184
[102]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/tx_pool.go#L1338-L1345
[103]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/tx_pool.go#L254
[104]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/tx_pool.go#L536
[105]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/miner/worker.go#L280
[106]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/miner/worker.go#L293-L296
[107]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/miner/worker.go#L531-L627
[108]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/miner/worker.go#L456-L477
[109]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/miner/worker.go#L436
[110]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/miner/worker.go#L456-L459
[111]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/miner/worker.go#L533
[112]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/miner/worker.go#L534
[113]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/miner/worker.go#L1114-L1117
[114]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/miner/worker.go#L982-L989
[115]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/miner/worker.go#L990-L998
[116]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/miner/worker.go#L1003
[117]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/miner/worker.go#L1004
[118]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/miner/worker.go#L1006
[119]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/miner/worker.go#L1017
[120]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/miner/worker.go#L1024-L1027
[121]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/consensus/ethash/consensus.go#L587
[122]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/consensus/ethash/consensus.go#L337-L351
[123]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/miner/worker.go#L1031-L1035
[124]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/miner/worker.go#L758-L768
[125]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/miner/worker.go#L1128
[126]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/miner/worker.go#L1063
[127]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/miner/worker.go#L1071-L1082
[128]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/miner/worker.go#L849
[129]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/miner/worker.go#L901-L904
[130]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/miner/worker.go#L835
[131]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/miner/worker.go#L87
[132]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/miner/worker.go#L90
[133]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/miner/worker.go#L836
[134]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/miner/worker.go#L838
[135]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/miner/worker.go#L839-L842
[136]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/state_processor.go#L144
[137]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/state_processor.go#L145
[138]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/types/transaction.go#L563
[139]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/types/transaction.go#L565
[140]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/types/transaction.go#L612
[141]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/types/transaction_signing.go#L195
[142]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/state_processor.go#L149-L151
[143]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/evm.go#L58-L69
[144]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/state_processor.go#L151
[145]: https://en.wikipedia.org/wiki/Stack_machine
[146]: https://en.wikipedia.org/wiki/256-bit_computing
[147]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/vm/evm.go#L128
[148]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/vm/evm.go#L137
[149]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/vm/interpreter.go#L72-L101
[150]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/state_processor.go#L97-L98
[151]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/state_processor.go#L101
[152]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/state_transition.go#L181
[153]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/state_transition.go#L279-L284
[154]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/state_transition.go#L287
[155]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/state_transition.go#L218-L224
[156]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/state_transition.go#L225-L228
[157]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/state_transition.go#L229-L233
[158]: https://eips.ethereum.org/EIPS/eip-3607
[159]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/state_transition.go#L239-L246
[160]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/state_transition.go#L247-L250
[161]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/state_transition.go#L253
[162]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/state_transition.go#L259
[163]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/state_transition.go#L201-L203
[164]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/state_transition.go#L204-L206
[165]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/state_transition.go#L210
[166]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/state_transition.go#L305-L313
[167]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/state_transition.go#L124
[168]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/params/protocol_params.go#L32
[169]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/state_transition.go#L124
[170]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/params/protocol_params.go#L88
[171]: https://eips.ethereum.org/EIPS/eip-2028
[172]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/params/protocol_params.go#L34
[173]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/state_transition.go#L124
[174]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/state_transition.go#L316-L318
[175]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/state_transition.go#L320-L323
[176]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/state_transition.go#L302
[177]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/state_transition.go#L332
[178]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/state_transition.go#L333
[179]: https://www.youtube.com/watch?v=wMOkm57vu0k
[180]: https://www.evm.codes
[181]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/vm/evm.go#L168
[182]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/vm/evm.go#L164-L167
[183]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/vm/evm.go#L169-L172
[184]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/params/protocol_params.go#L75
[185]: https://medium.com/arbitrary-execution/testing-the-limits-of-evm-stack-depth-c40ba55ca78e
[186]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/params/protocol_params.go#L79
[187]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/vm/evm.go#L173-L176
[188]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/vm/evm.go#L196
[189]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/vm/evm.go#L177
[190]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/vm/evm.go#L235-L236
[191]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/vm/evm.go#L180
[192]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/vm/evm.go#L194
[193]: https://eips.ethereum.org/EIPS/eip-158
[194]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/vm/evm.go#L181
[195]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/vm/evm.go#L214-L231
[196]: https://ethereum.github.io/yellowpaper/paper.pdf#section.8
[197]: https://etherscan.io/address/0x0000000000000000000000000000000000000001
[198]: https://etherscan.io/address/0x0000000000000000000000000000000000000009
[199]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/vm/contracts.go#L45-L93
[200]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/vm/instructions.go#L407-L408
[201]: https://etherscan.io/tx/0xbdba0ec52ae2c9785468a453745b9f7024af6e165887a0e9038a5c2d2fea3909
[202]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/vm/evm.go#L219
[203]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/vm/evm.go#L220-L221
[204]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/vm/evm.go#L228
[205]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/vm/interpreter.go#L141
[206]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/params/protocol_params.go#L79
[207]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/vm/interpreter.go#L140
[208]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/vm/interpreter.go#L150
[209]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/vm/interpreter.go#L164
[210]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/vm/interpreter.go#L118-L120
[211]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/vm/interpreter.go#L122-L127
[212]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/vm/evm.go#L228
[213]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/vm/instructions.go#L524-L527
[214]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/vm/instructions.go#L580-L583
[215]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/vm/instructions.go#L626-L629
[216]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/vm/instructions.go#L826-L829
[217]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/vm/instructions.go#L679-L681
[218]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/vm/instructions.go#L846-L848
[219]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/vm/interpreter.go#L181-L244
[220]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/vm/interpreter.go#L239
[221]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/vm/interpreter.go#L188-L189
[222]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/vm/jump_table.go#L94-L99
[223]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/vm/interpreter.go#L74-L75
[224]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/vm/interpreter.go#L191-L196
[225]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/vm/interpreter.go#L197-L199
[226]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/vm/interpreter.go#L221-L225
[227]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/vm/interpreter.go#L201-L217
[228]: https://www.evm.codes/about#memoryexpansion
[229]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/vm/instructions.go
[230]: https://soliditylang.org/
[231]: https://etherscan.io/address/0x6B175474E89094C44Da98b954EedeAC495271d0F#code
[232]: https://github.com/makerdao/dss/blob/master/src/dai.sol
[233]: https://samczsun.com/hiding-in-plain-sight/
[234]: https://sourcify.dev
[235]: https://etherscan.io/address/0x6B175474E89094C44Da98b954EedeAC495271d0F#code#L6
[236]: https://etherscan.io/address/0x6B175474E89094C44Da98b954EedeAC495271d0F#code#L122
[237]: https://etherscan.io/address/0x6B175474E89094C44Da98b954EedeAC495271d0F#code#L123
[238]: https://docs.soliditylang.org/en/v0.5.12/units-and-global-variables.html#block-and-transaction-properties
[239]: https://etherscan.io/address/0x6B175474E89094C44Da98b954EedeAC495271d0F#code#L125
[240]: https://etherscan.io/address/0x6B175474E89094C44Da98b954EedeAC495271d0F#code#L128
[241]: https://etherscan.io/address/0x6B175474E89094C44Da98b954EedeAC495271d0F#code#L90
[242]: https://etherscan.io/address/0x6B175474E89094C44Da98b954EedeAC495271d0F#code#L129
[243]: https://etherscan.io/address/0x6B175474E89094C44Da98b954EedeAC495271d0F#code#L133
[244]: https://etherscan.io/address/0x6B175474E89094C44Da98b954EedeAC495271d0F#code#L135
[245]: https://eips.ethereum.org/EIPS/eip-20#events
[246]: https://etherscan.io/address/0x6B175474E89094C44Da98b954EedeAC495271d0F#code#L136
[247]: https://eips.ethereum.org/EIPS/eip-20#methods
[248]: https://blog.openzeppelin.com/deconstructing-a-solidity-contract-part-i-introduction-832efd2d7737/
[249]: https://noxx.substack.com/p/evm-deep-dives-the-path-to-shadowy
[250]: https://library.dedaub.com/contracts/Ethereum/6b175474e89094c44da98b954eedeac495271d0f/disassembled
[251]: https://gist.github.com/tinchoabbate/508b2b51df7043a524be7debb738992c
[252]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/vm/instructions.go#L505-L506
[253]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/vm/instructions.go#L277-L281
[254]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/vm/instructions.go#L294-L297
[255]: https://docs.soliditylang.org/en/v0.5.15/abi-spec.html#function-selector
[256]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/vm/instructions.go#L283-L292
[257]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/vm/instructions.go#L286
[258]: https://www.evm.codes/#1c
[259]: https://gist.github.com/tinchoabbate/508b2b51df7043a524be7debb738992c#file-dai-asm-L3346-L3353
[260]: https://docs.soliditylang.org/en/v0.5.15/miscellaneous.html#mappings-and-dynamic-arrays
[261]: https://gist.github.com/tinchoabbate/508b2b51df7043a524be7debb738992c#file-dai-asm-L1583-L1620
[262]: https://gist.github.com/tinchoabbate/508b2b51df7043a524be7debb738992c#file-dai-asm-L3444-L3465
[263]: https://gist.github.com/tinchoabbate/508b2b51df7043a524be7debb738992c#file-dai-asm-L1884-L1907
[264]: https://gist.github.com/tinchoabbate/508b2b51df7043a524be7debb738992c#file-dai-asm-L3467-L3487
[265]: https://gist.github.com/tinchoabbate/508b2b51df7043a524be7debb738992c#file-dai-asm-L1908-L1929
[266]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/vm/instructions.go#L844-L869
[267]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/vm/instructions.go#L849
[268]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/vm/instructions.go#L850-L851
[269]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/vm/instructions.go#L853
[270]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/vm/instructions.go#L854
[271]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/vm/instructions.go#L857
[272]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/vm/instructions.go#L858-L865
[273]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/vm/interpreter.go#L181
[274]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/vm/instructions.go#L807
[275]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/vm/interpreter.go#L246-L248
[276]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/vm/evm.go#L228
[277]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/vm/evm.go#L235-L243
[278]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/vm/evm.go#L244
[279]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/state_transition.go#L339-L342
[280]: https://eips.ethereum.org/EIPS/eip-3529
[281]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/state_transition.go#L364-L366
[282]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/state_transition.go#L370
[283]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/state_transition.go#L343-L347
[284]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/state_transition.go#L345
[285]: https://watchtheburn.com/
[286]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/state_transition.go#L349-L353
[287]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/state_transition.go#L181
[288]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/state_processor.go#L101
[289]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/state_processor.go#L109
[290]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/state_processor.go#L113
[291]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/state_processor.go#L118-L122
[292]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/state_processor.go#L123
[293]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/state_processor.go#L124
[294]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/state_processor.go#L128
[295]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/state_processor.go#L132
[296]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/state_processor.go#L133
[297]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/state_processor.go#L134-L136
[298]: https://noxx.substack.com/i/55077458/bloom-filters
[299]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/miner/worker.go#L1155
[300]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/consensus/ethash/consensus.go#L595
[301]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/consensus/ethash/consensus.go#L645
[302]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/consensus/ethash/consensus.go#L645
[303]: https://ethereum.org/en/glossary/#ommer
[304]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/consensus/ethash/consensus.go#L596
[305]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/consensus/ethash/consensus.go#L606
[306]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/types/block.go#L200-L228
[307]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/types/block.go#L206
[308]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/types/block.go#L214
[309]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/miner/worker.go#L1162
[310]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/miner/worker.go#L648
[311]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/miner/worker.go#L668
[312]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/consensus/ethash/sealer.go#L99
[313]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/consensus/ethash/sealer.go#L182
[314]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/consensus/ethash/sealer.go#L182
[315]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/consensus/ethash/sealer.go#L112
[316]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/miner/worker.go#L687
[317]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/miner/worker.go#L712-L732
[318]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/miner/worker.go#L733-L734
[319]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/miner/worker.go#L742-L743
[320]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/miner/worker.go#L745-L746
[321]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/event/event.go#L97
[322]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/eth/handler.go#L647
[323]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/eth/handler.go#L652
[324]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/eth/handler.go#L653
[325]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/eth/handler.go#L586-L590
[326]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/eth/protocols/eth/peer.go#L291
[327]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/eth/protocols/eth/broadcast.go#L46
[328]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/eth/protocols/eth/peer.go#L281
[329]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/eth/handler.go#L597
[330]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/eth/handler.go#L562-L572
[331]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/eth/protocols/eth/handler.go#L186
[332]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/eth/protocols/eth/handler.go#L167-L182
[333]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/eth/protocols/eth/handler.go#L215
[334]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/eth/protocols/eth/handlers.go#L328
[335]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/eth/protocols/eth/handlers.go#L329-L333
[336]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/eth/protocols/eth/handlers.go#L334-L344
[337]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/types/block.go#L128-L143
[338]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/eth/protocols/eth/handlers.go#L337-L340
[339]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/eth/protocols/eth/handlers.go#L341-L344
[340]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/eth/protocols/eth/handlers.go#L349
[341]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/eth/protocols/eth/handlers.go#L351
[342]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/eth/handler_eth.go#L67-L68
[343]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/eth/handler_eth.go#L123-L124
[344]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/eth/fetcher/block_fetcher.go#L268
[345]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/eth/fetcher/block_fetcher.go#L420
[346]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/eth/fetcher/block_fetcher.go#L429
[347]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/eth/fetcher/block_fetcher.go#L796
[348]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/eth/fetcher/block_fetcher.go#L354
[349]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/eth/fetcher/block_fetcher.go#L376
[350]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/eth/fetcher/block_fetcher.go#L848-L853
[351]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/eth/fetcher/block_fetcher.go#L855
[352]: https://ethereum.github.io/yellowpaper/paper.pdf#subsection.4.3
[353]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/consensus/ethash/consensus.go#L263
[354]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/consensus/ethash/consensus.go#L310
[355]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/consensus/ethash/consensus.go#L274
[356]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/consensus/ethash/consensus.go#L270
[357]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/consensus/ethash/consensus.go#L305
[358]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/eth/fetcher/block_fetcher.go#L859
[359]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/eth/fetcher/block_fetcher.go#L871
[360]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/blockchain.go#L1414-L1595
[361]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/blockchain.go#L1603
[362]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/blockchain.go#L1632
[363]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/blockchain.go#L1654
[364]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/block_validator.go#L81
[365]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/core/blockchain.go#L1669-L1674
[366]: https://github.com/ethereum/go-ethereum/blob/v1.10.18/eth/fetcher/block_fetcher.go#L877
